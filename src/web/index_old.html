<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gmail Client</title>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --midnight-black: #0a0e27;
            --navy: #1a2332;
            --navy-dark: #141b26;
            --ocean: #2d4a5e;
            --ocean-light: #3d5f7a;
            --ocean-bright: #4a7c9e;
            --accent: #5b9bd5;
            --accent-bright: #7bb3d9;
            --success: #4caf50;
            --danger: #f44336;
            --text-primary: #e8eef4;
            --text-secondary: #b8c5d1;
            --text-tertiary: #8a9ba8;
            --border: #2a3441;
            --border-light: #1f2833;
            --shadow-sm: 0 2px 4px rgba(0, 0, 0, 0.3);
            --shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 8px 16px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 16px 32px rgba(0, 0, 0, 0.6);
            --radius: 0px;
            --radius-sm: 0px;
            --radius-lg: 0px;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--midnight-black);
            background-image: 
                radial-gradient(circle at 20% 50%, rgba(45, 74, 94, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(91, 155, 213, 0.1) 0%, transparent 50%);
            background-attachment: fixed;
            height: 100vh;
            display: flex;
            flex-direction: column;
            color: var(--text-primary);
            line-height: 1.6;
        }

        .header {
            background: var(--navy);
            border-bottom: 2px solid var(--border);
            padding: 18px 32px;
            display: flex;
            align-items: center;
            gap: 16px;
            box-shadow: var(--shadow-md);
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            font-size: 24px;
            font-weight: 300;
            color: var(--accent-bright);
            letter-spacing: 4px;
            text-transform: uppercase;
            font-family: 'Inter', sans-serif;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
            gap: 2px;
            padding: 2px;
            background: var(--midnight-black);
        }

        .sidebar {
            width: 300px;
            background: var(--navy);
            border: 1px solid var(--border);
            padding: 24px;
            box-shadow: var(--shadow);
            overflow-y: auto;
            max-height: calc(100vh - 80px);
        }

        .auth-section {
            margin-bottom: 32px;
        }

        .auth-section-title {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-tertiary);
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .account-item {
            padding: 20px;
            margin-bottom: 8px;
            border: 1px solid var(--border);
            background: var(--navy-dark);
            transition: all 0.2s ease;
            box-shadow: var(--shadow-sm);
        }

        .account-item:hover {
            border-color: var(--accent);
            background: var(--ocean);
            box-shadow: var(--shadow);
        }

        .account-item.authenticated {
            border-left: 3px solid var(--success);
            background: var(--navy-dark);
        }

        .account-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .account-name {
            font-size: 15px;
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 1px;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .account-email {
            font-size: 14px;
            color: var(--text-secondary);
            margin-bottom: 16px;
            font-weight: 300;
        }

        .account-email.authenticated {
            color: var(--accent-bright);
            font-weight: 400;
        }

        .auth-btn {
            width: 100%;
            padding: 12px 20px;
            background: var(--ocean);
            color: var(--text-primary);
            border: 1px solid var(--accent);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .auth-btn:hover {
            background: var(--accent);
            color: var(--midnight-black);
            box-shadow: 0 0 12px rgba(91, 155, 213, 0.4);
        }

        .auth-btn:active {
            background: var(--ocean-light);
        }

        .auth-btn.authenticated {
            background: transparent;
            border-color: var(--success);
            color: var(--success);
            cursor: default;
        }

        .auth-status {
            font-size: 12px;
            color: var(--text-tertiary);
            margin-top: 10px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .auth-status.authenticated {
            color: var(--success);
        }

        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--navy);
            border: 1px solid var(--border);
            box-shadow: var(--shadow);
            overflow: hidden;
        }

        .email-header {
            padding: 24px 32px;
            border-bottom: 2px solid var(--border);
            background: var(--navy-dark);
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
            flex-wrap: wrap;
        }

        .label-filter-controls {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-left: 16px;
        }

        .label-select {
            padding: 10px 16px;
            border: 1px solid var(--border);
            font-size: 14px;
            background-color: var(--navy-dark);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .label-select:hover {
            border-color: var(--accent);
            background: var(--ocean);
        }

        .label-select:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 8px rgba(91, 155, 213, 0.3);
        }

        .threshold-control {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .threshold-slider {
            width: 150px;
            height: 4px;
            background: var(--navy-dark);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
            transition: all 0.2s ease;
        }

        .threshold-slider:hover {
            background: var(--ocean);
        }

        .threshold-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            box-shadow: 0 0 8px rgba(91, 155, 213, 0.6);
            transition: all 0.2s ease;
        }

        .threshold-slider::-webkit-slider-thumb:hover {
            background: var(--accent-bright);
            box-shadow: 0 0 12px rgba(91, 155, 213, 0.8);
        }

        .threshold-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border: none;
            box-shadow: 0 0 8px rgba(91, 155, 213, 0.6);
            transition: all 0.2s ease;
        }

        .threshold-slider::-moz-range-thumb:hover {
            background: var(--accent-bright);
            box-shadow: 0 0 12px rgba(91, 155, 213, 0.8);
        }

        .threshold-value {
            font-size: 13px;
            color: var(--text-secondary);
            min-width: 40px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .email-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .email-count {
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .email-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: var(--accent);
            transition: all 0.2s ease;
        }

        .archive-btn {
            padding: 12px 24px;
            background: var(--ocean);
            color: var(--text-primary);
            border: 1px solid var(--accent);
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .archive-btn:hover:not(:disabled) {
            background: var(--accent);
            color: var(--midnight-black);
            box-shadow: 0 0 12px rgba(91, 155, 213, 0.4);
        }

        .archive-btn:active:not(:disabled) {
            background: var(--ocean-light);
        }

        .archive-btn:disabled {
            background: var(--navy-dark);
            color: var(--text-tertiary);
            border-color: var(--border);
            cursor: not-allowed;
        }

        .progress-container {
            padding: 20px 32px;
            background: var(--navy-dark);
            border-bottom: 2px solid var(--border);
        }

        .account-progress {
            margin-bottom: 12px;
        }

        .account-progress:last-child {
            margin-bottom: 0;
        }

        .account-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-size: 13px;
            color: var(--text-secondary);
        }

        .account-progress-name {
            font-weight: 500;
            color: var(--text-primary);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .account-progress-stats {
            font-size: 12px;
            font-weight: 500;
            letter-spacing: 1px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: var(--navy);
            overflow: hidden;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        .progress-fill {
            height: 100%;
            background: var(--accent);
            transition: width 0.5s ease;
            box-shadow: 0 0 8px rgba(91, 155, 213, 0.6);
        }

        .progress-bar.loading {
            position: relative;
            overflow: hidden;
        }

        .progress-bar.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .email-list {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        .loading-more {
            padding: 24px;
            text-align: center;
            color: var(--text-tertiary);
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .loading-more-spinner {
            display: inline-block;
            width: 14px;
            height: 14px;
            border: 2px solid var(--navy-dark);
            border-top-color: var(--accent);
            animation: spin 0.8s linear infinite;
            margin-right: 10px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .email-item {
            padding: 20px 32px;
            border-bottom: 2px solid var(--border);
            display: grid;
            grid-template-columns: 140px 1fr 160px;
            grid-template-rows: auto auto auto auto auto;
            gap: 6px 20px;
            cursor: pointer;
            position: relative;
            transition: all 0.2s ease;
            background: var(--navy);
        }

        .email-item:hover {
            background: var(--ocean);
            border-left: 4px solid var(--accent);
            padding-left: 28px;
        }

        .email-item-checkbox {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #1a73e8;
            z-index: 10;
        }

        .email-item.has-checkbox {
            padding-left: 48px;
        }

        .email-field-label {
            font-size: 11px;
            font-weight: 600;
            color: var(--text-tertiary);
            letter-spacing: 1.5px;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .email-field-value {
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 400;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-sender-label {
            grid-column: 1;
            grid-row: 1;
        }

        .email-sender-value {
            grid-column: 1;
            grid-row: 2;
            font-weight: 500;
            color: var(--accent-bright);
        }

        .email-subject-label {
            grid-column: 2;
            grid-row: 1;
        }

        .email-subject-value {
            grid-column: 2;
            grid-row: 2;
            font-weight: 500;
            color: var(--text-primary);
            font-size: 15px;
        }

        .email-time-label {
            grid-column: 3;
            grid-row: 1;
            text-align: right;
        }

        .email-time-value {
            grid-column: 3;
            grid-row: 2;
            text-align: right;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .email-to-label {
            grid-column: 1;
            grid-row: 3;
        }

        .email-to-value {
            grid-column: 1;
            grid-row: 4;
            color: var(--text-secondary);
            font-size: 13px;
        }

        .email-snippet {
            grid-column: 2 / -1;
            grid-row: 3 / 5;
            font-size: 13px;
            color: var(--text-secondary);
            line-height: 1.7;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 3;
            line-clamp: 3;
            -webkit-box-orient: vertical;
            font-weight: 300;
            padding-left: 20px;
            border-left: 1px solid var(--border);
        }

        .label-badge {
            display: inline-block;
            color: var(--text-primary);
            font-size: 11px;
            font-weight: 600;
            padding: 5px 10px;
            margin-left: 6px;
            margin-top: 4px;
            vertical-align: middle;
            transition: all 0.2s ease;
            background: var(--ocean);
            border: 1px solid var(--accent);
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .label-badge:hover:not(.loading) {
            background: var(--accent);
            color: var(--midnight-black);
            box-shadow: 0 0 12px rgba(91, 155, 213, 0.6);
            border-color: var(--accent-bright);
        }

        .label-badge.add-button {
            background: var(--navy-dark);
            border: 2px solid var(--accent-bright);
            color: var(--accent-bright);
            font-weight: 600;
        }

        .label-badge.add-button:hover:not(.loading) {
            background: var(--accent-bright);
            color: var(--midnight-black);
            box-shadow: 0 0 16px rgba(123, 179, 217, 0.8);
        }

        .label-badge.loading {
            opacity: 0.6;
            cursor: wait;
            pointer-events: none;
            min-width: fit-content;
            white-space: nowrap;
        }

        .label-badge.add-button {
            opacity: 0.3;
            border-style: dashed;
        }

        .label-badge.add-button:hover:not(.loading) {
            opacity: 0.6;
            background-color: #1a73e8;
        }

        .label-badge .delete-icon {
            margin-left: 4px;
            cursor: pointer;
            opacity: 0.8;
            font-weight: bold;
            font-size: 18px;
            line-height: 1;
            transition: opacity 0.2s, transform 0.2s;
        }

        .label-badge .delete-icon:hover {
            opacity: 1;
            transform: scale(1.1);
        }

        .label-badge.loading .delete-icon {
            pointer-events: none;
        }

        .label-badge .loading-spinner {
            display: inline-block;
            width: 10px;
            height: 10px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
            margin-left: 4px;
            vertical-align: middle;
            flex-shrink: 0;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: var(--text-tertiary);
            padding: 60px 20px;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 24px;
            opacity: 0.4;
        }

        .inbox-zero {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 80px 40px;
            position: relative;
            overflow: hidden;
            background: 
                radial-gradient(circle at 50% 50%, rgba(91, 155, 213, 0.15) 0%, transparent 70%),
                radial-gradient(circle at 20% 30%, rgba(76, 175, 80, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 193, 7, 0.1) 0%, transparent 50%);
        }

        .inbox-zero::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: 
                radial-gradient(circle, rgba(91, 155, 213, 0.1) 1px, transparent 1px),
                radial-gradient(circle, rgba(76, 175, 80, 0.08) 1px, transparent 1px);
            background-size: 50px 50px, 80px 80px;
            animation: sparkle 20s linear infinite;
            pointer-events: none;
        }

        @keyframes sparkle {
            0% { transform: rotate(0deg) translate(0, 0); }
            100% { transform: rotate(360deg) translate(0, 0); }
        }

        .inbox-zero-crown {
            font-size: 120px;
            margin-bottom: 32px;
            animation: float 3s ease-in-out infinite;
            filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.5));
            position: relative;
            z-index: 1;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px) rotate(-5deg); }
            50% { transform: translateY(-20px) rotate(5deg); }
        }

        .inbox-zero-title {
            font-size: 48px;
            font-weight: 700;
            background: linear-gradient(135deg, #ffd700 0%, #ffed4e 25%, #4caf50 50%, #5b9bd5 75%, #ffd700 100%);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 16px;
            animation: gradient-shift 4s ease infinite;
            text-align: center;
            position: relative;
            z-index: 1;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        @keyframes gradient-shift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .inbox-zero-subtitle {
            font-size: 24px;
            color: var(--accent-bright);
            margin-bottom: 8px;
            font-weight: 500;
            position: relative;
            z-index: 1;
            text-align: center;
        }

        .inbox-zero-message {
            font-size: 18px;
            color: var(--text-secondary);
            text-align: center;
            max-width: 600px;
            line-height: 1.8;
            position: relative;
            z-index: 1;
            margin-top: 24px;
        }

        .inbox-zero-stats {
            display: flex;
            gap: 40px;
            margin-top: 40px;
            position: relative;
            z-index: 1;
        }

        .inbox-zero-stat {
            text-align: center;
            padding: 20px 30px;
            background: rgba(91, 155, 213, 0.1);
            border: 1px solid rgba(91, 155, 213, 0.3);
            border-radius: 8px;
            backdrop-filter: blur(10px);
        }

        .inbox-zero-stat-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--accent-bright);
            margin-bottom: 8px;
        }

        .inbox-zero-stat-label {
            font-size: 14px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ffd700;
            animation: confetti-fall 3s linear infinite;
            opacity: 0.8;
            z-index: 10;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        .loading {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 15px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .error {
            padding: 16px 24px;
            background: var(--navy-dark);
            color: var(--danger);
            margin: 16px 32px;
            border-left: 3px solid var(--danger);
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(10, 14, 39, 0.9);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .modal {
            background: var(--navy);
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            box-shadow: var(--shadow-lg);
            position: relative;
            animation: slideUp 0.2s ease;
            border: 1px solid var(--border);
        }

        @keyframes slideUp {
            from {
                transform: translateY(10px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            padding: 28px 32px;
            border-bottom: 2px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-shrink: 0;
            background: var(--navy-dark);
        }

        .modal-header-content {
            flex: 1;
            min-width: 0;
        }

        .modal-title {
            font-size: 22px;
            font-weight: 400;
            color: var(--accent-bright);
            margin-bottom: 16px;
            word-wrap: break-word;
            letter-spacing: 1px;
            line-height: 1.4;
        }

        .modal-meta {
            font-size: 14px;
            color: var(--text-secondary);
            line-height: 1.8;
        }

        .modal-meta-row {
            margin-bottom: 10px;
        }

        .modal-meta-label {
            font-weight: 500;
            display: inline-block;
            min-width: 60px;
            color: var(--text-primary);
            letter-spacing: 1px;
            text-transform: uppercase;
            font-size: 12px;
        }

        .modal-close {
            background: transparent;
            border: 1px solid var(--border);
            font-size: 20px;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
            margin-left: 16px;
            transition: all 0.2s ease;
        }

        .modal-close:hover {
            background: var(--danger);
            border-color: var(--danger);
            color: white;
        }

        .modal-body {
            padding: 32px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
            background: var(--navy);
        }

        .modal-body-tabs {
            display: flex;
            border-bottom: 2px solid var(--border);
            margin-bottom: 28px;
            gap: 2px;
        }

        .modal-tab {
            padding: 12px 24px;
            background: var(--navy-dark);
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 13px;
            color: var(--text-secondary);
            font-weight: 500;
            transition: all 0.2s ease;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .modal-tab.active {
            color: var(--accent-bright);
            border-bottom-color: var(--accent);
            background: var(--navy);
        }

        .modal-tab:hover:not(.active) {
            background: var(--ocean);
            color: var(--text-primary);
        }

        .modal-content {
            font-size: 15px;
            line-height: 1.8;
            color: var(--text-primary);
            font-weight: 300;
        }

        .modal-content-html {
            max-width: 100%;
            word-wrap: break-word;
        }

        .modal-content-html img {
            max-width: 100%;
            height: auto;
            margin: 16px 0;
            border: 1px solid var(--border);
        }

        .modal-content-text {
            white-space: pre-wrap;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--navy-dark);
            padding: 24px;
            border: 1px solid var(--border);
            font-weight: 300;
        }

        .modal-loading {
            text-align: center;
            padding: 60px;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 400;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .modal-error {
            padding: 16px 24px;
            background: var(--navy-dark);
            color: var(--danger);
            margin: 16px 0;
            border-left: 3px solid var(--danger);
            font-weight: 400;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Filterbox</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="auth-section">
                <div class="auth-section-title">Accounts</div>
                <div id="accountsList">Loading accounts...</div>
            </div>
        </div>

        <div class="content-area">
            <div class="email-header">
                <div class="email-header-left">
                    <input type="checkbox" class="email-checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                    <div class="email-count" id="emailCount">Loading...</div>
                    <label style="display: flex; align-items: center; gap: 8px; margin-left: 16px; font-size: 13px; color: var(--text-secondary); cursor: pointer; font-weight: 400; letter-spacing: 0.5px; text-transform: uppercase;">
                        <input type="checkbox" id="filterUnlabeledCheckbox" onchange="toggleUnlabeledFilter()" style="cursor: pointer; width: 18px; height: 18px; accent-color: var(--accent);">
                        <span>Show only unlabeled</span>
                    </label>
                    <div class="label-filter-controls">
                        <select class="label-select" id="labelFilterSelect" onchange="onLabelFilterChange()">
                            <option value="">Filter by label...</option>
                        </select>
                        <div class="threshold-control" id="thresholdControl" style="display: none;">
                            <input type="range" class="threshold-slider" id="thresholdSlider" min="0" max="100" value="50" oninput="onThresholdChange(this.value)">
                            <span class="threshold-value" id="thresholdValue">50%</span>
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    <button class="archive-btn" id="selectLabeledBtn" onclick="selectLabeledEmails()">Select Labeled</button>
                    <button class="archive-btn" id="archiveBtn" onclick="archiveSelectedEmails()" disabled>Archive</button>
                </div>
            </div>
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div id="accountProgressBars"></div>
            </div>
            <div class="email-list" id="emailList">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Email Modal -->
    <div class="modal-overlay" id="emailModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-header-content">
                    <div class="modal-title" id="modalTitle">Loading...</div>
                    <div class="modal-meta" id="modalMeta"></div>
                </div>
                <button class="modal-close" onclick="closeEmailModal()" aria-label="Close">Ã—</button>
            </div>
            <div class="modal-body" id="modalBody">
                <div class="modal-loading">Loading email...</div>
            </div>
        </div>
    </div>

    <script>
        let accounts = [];
        let emailAccountMap = {}; // Map message_id to account_id
        let allEmails = []; // Store all loaded emails
        let nextPageToken = null;
        let totalEmailCount = 0;
        let isLoading = false;
        let hasMoreEmails = true;
        const BATCH_SIZE = 200; // Number of emails to load per batch
        let accountCounts = {}; // Store email counts per account
        let selectedEmails = new Set(); // Set of selected email IDs
        let showOnlyUnlabeled = false; // Filter to show only emails with 0 labels
        let selectedLabelFilter = ''; // Selected label for filtering
        let labelThreshold = 50; // Threshold for label score filtering

        // Label types configuration - loaded from API
        let LABEL_TYPES = [];

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('auth_success') === 'true') {
            setTimeout(async () => {
                await loadLabels();
                await loadAccounts();
                initializeEmails();
            }, 500);
        }
        if (urlParams.get('auth_error')) {
            showError('Authentication failed: ' + urlParams.get('auth_error'));
        }

        // Load labels first, then accounts, then initialize emails
        (async () => {
            await loadLabels();
            await loadAccounts();
            initializeEmails();
        })();

        // Set up infinite scroll
        const emailList = document.getElementById('emailList');
        emailList.addEventListener('scroll', handleScroll);

        async function loadLabels() {
            try {
                const response = await fetch('/api/labels');
                const data = await response.json();
                LABEL_TYPES = data.labels.map(label => ({
                    name: label.name
                }));
                // Populate label filter select
                populateLabelFilter();
            } catch (error) {
                console.error('Error loading labels:', error);
                // Fallback to default labels
                LABEL_TYPES = [
                    { name: 'marketing' },
                    { name: 'noti' },
                    { name: 'event' },
                    { name: 'newsletter' }
                ];
                populateLabelFilter();
            }
        }

        function populateLabelFilter() {
            const select = document.getElementById('labelFilterSelect');
            if (!select) return;
            
            // Clear existing options except the first one
            select.innerHTML = '<option value="">Filter by label...</option>';
            
            // Add each label as an option
            LABEL_TYPES.forEach(label => {
                const option = document.createElement('option');
                option.value = label.name;
                option.textContent = label.name;
                select.appendChild(option);
            });
        }

        function onLabelFilterChange() {
            const select = document.getElementById('labelFilterSelect');
            const thresholdControl = document.getElementById('thresholdControl');
            
            selectedLabelFilter = select.value;
            
            if (selectedLabelFilter) {
                thresholdControl.style.display = 'flex';
                labelThreshold = 50;
                document.getElementById('thresholdSlider').value = 50;
                document.getElementById('thresholdValue').textContent = '50%';
            } else {
                thresholdControl.style.display = 'none';
                labelThreshold = 0;
                document.getElementById('thresholdSlider').value = 0;
                document.getElementById('thresholdValue').textContent = '0%';
            }
            
            renderEmails();
        }

        function onThresholdChange(value) {
            labelThreshold = parseInt(value);
            document.getElementById('thresholdValue').textContent = value + '%';
            renderEmails();
        }

        async function loadAccounts() {
            try {
                const response = await fetch('/api/accounts');
                const data = await response.json();
                accounts = data.accounts;
                renderAccounts();
            } catch (error) {
                console.error('Error loading accounts:', error);
                document.getElementById('accountsList').innerHTML = '<div class="error">Error loading accounts</div>';
            }
        }

        function renderAccounts() {
            const accountsList = document.getElementById('accountsList');
            if (accounts.length === 0) {
                accountsList.innerHTML = '<div style="color: #5f6368; font-size: 15px;">No accounts found. Add credentials-1.json through credentials-9.json to src/gmail/credentials/</div>';
                return;
            }

            accountsList.innerHTML = accounts.map(account => {
                const accountNum = account.account_id.replace('account', '');
                if (account.authenticated) {
                    return `
                        <div class="account-item authenticated">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                                <span style="color: #137333; font-size: 15px;">âœ“</span>
                            </div>
                            <div class="account-email authenticated">${escapeHtml(account.email || 'Authenticated')}</div>
                            <div class="auth-status authenticated">Authenticated</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="account-item">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                            </div>
                            <div class="account-email">Not authenticated</div>
                            <button class="auth-btn" onclick="startAuth('${escapeHtml(account.account_id)}')">Sign in</button>
                        </div>
                    `;
                }
            }).join('');
        }

        async function startAuth(accountId) {
            try {
                const response = await fetch(`/api/auth/start?account_id=${accountId}`);
                const data = await response.json();
                window.location.href = data.authorization_url;
            } catch (error) {
                showError('Failed to start authentication: ' + error.message);
            }
        }

        async function initializeEmails() {
            allEmails = [];
            nextPageToken = null;
            hasMoreEmails = true;
            
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = '<div class="loading">Loading emails...</div>';
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                return;
            }
            
            // Step 1: Fetch email counts for each account first
            accountCounts = {};
            try {
                const countsResponse = await fetch('/api/emails/account-counts');
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    accountCounts = countsData.account_counts || {};
                    
                    // Calculate total count
                    totalEmailCount = Object.values(accountCounts).reduce((sum, count) => sum + count, 0);
                    updateEmailCount(0);
                }
            } catch (error) {
                console.error('Error loading email counts:', error);
            }
            
            // Step 2: Initialize progress bars with actual counts (min of BATCH_SIZE and total)
            accountProgress = {};
            authenticatedAccounts.forEach(account => {
                const totalCount = accountCounts[account.account_id] || 0;
                const batchTotal = Math.min(totalCount, BATCH_SIZE);
                accountProgress[account.account_id] = {
                    current: 0,
                    total: batchTotal, // This is what we'll track progress against
                    totalCount: totalCount, // Store full count for display
                    percent: 0
                };
            });
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            updateAccountProgressBars();
            
            // Step 3: Start streaming emails from all accounts in parallel
            await loadMoreEmails(true);
        }

        async function loadMoreEmails(isInitial = false) {
            if (isLoading || (!hasMoreEmails && !isInitial)) {
                return;
            }

            isLoading = true;
            const emailList = document.getElementById('emailList');
            const progressContainer = document.getElementById('progressContainer');

            // Show progress on initial load
            if (isInitial) {
                accountProgress = {}; // Reset progress tracking
                allEmails = []; // Clear existing emails on initial load
            }

            try {
                // Use streaming endpoint for initial load, regular endpoint for pagination
                if (isInitial) {
                    await loadEmailsStream();
                } else {
                    await loadEmailsRegular();
                }

                // Render emails
                renderEmails();

                // Progress hiding is handled in loadEmailsStream

            } catch (error) {
                console.error('Error loading emails:', error);
                if (isInitial) {
                    emailList.innerHTML = `<div class="error">Error loading emails: ${error.message}</div>`;
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error';
                    errorDiv.textContent = `Error loading more emails: ${error.message}`;
                    emailList.appendChild(errorDiv);
                }
            } finally {
                isLoading = false;
            }
        }

        let accountProgress = {}; // Track progress per account
        let accountStreams = {}; // Track EventSource streams per account

        async function loadEmailsStream() {
            const progressContainer = document.getElementById('progressContainer');
            const accountProgressBars = document.getElementById('accountProgressBars');
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                return;
            }
            
            // Ensure progress container is visible
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Ensure accountProgress is initialized for all accounts with correct totals
            authenticatedAccounts.forEach(account => {
                const inboxCount = accountCounts[account.account_id] || BATCH_SIZE;
                const maxResults = Math.min(inboxCount, BATCH_SIZE);
                if (!accountProgress[account.account_id]) {
                    accountProgress[account.account_id] = {
                        current: 0,
                        total: maxResults,
                        totalCount: inboxCount,
                        percent: 0
                    };
                } else {
                    // Update total to match what we're actually requesting
                    accountProgress[account.account_id].total = maxResults;
                    accountProgress[account.account_id].totalCount = inboxCount;
                }
            });
            updateAccountProgressBars();
            
            // Start streaming from all accounts in parallel
            const streamPromises = authenticatedAccounts.map(account => {
                return new Promise((resolve, reject) => {
                    // Use min(200, inbox_length) for max_results
                    const inboxCount = accountCounts[account.account_id] || BATCH_SIZE;
                    const maxResults = Math.min(inboxCount, BATCH_SIZE);
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${maxResults}`;
                    
                    // Parse nextPageToken to get token for this account if needed
                    if (nextPageToken) {
                        const tokens = nextPageToken.split(',');
                        for (const tokenPair of tokens) {
                            if (tokenPair.includes(':')) {
                                const [accId, token] = tokenPair.split(':', 2);
                                if (accId === account.account_id) {
                                    url += `&page_token=${encodeURIComponent(token)}`;
                                    break;
                                }
                            }
                        }
                    }
                    
                    const eventSource = new EventSource(url);
                    accountStreams[account.account_id] = eventSource;
                    
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress for this account (preserve totalCount and total if they exist)
                                const existing = accountProgress[data.account_id] || {};
                                // Use the existing total (which is min(BATCH_SIZE, totalCount)) for progress tracking
                                const progressTotal = existing.total || data.total || 0;
                                accountProgress[data.account_id] = {
                                    current: data.current || 0,
                                    total: progressTotal, // Keep the batch total we set initially
                                    totalCount: existing.totalCount || 0, // Preserve full count
                                    percent: progressTotal > 0 ? Math.min((data.current || 0) / progressTotal * 100, 100) : 0
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                // Add email as it arrives
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                // Check for duplicates
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally for better UX
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    // Timeout after 60 seconds
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Mark all accounts as complete in progress
                authenticatedAccounts.forEach(account => {
                    if (accountProgress[account.account_id]) {
                        const progress = accountProgress[account.account_id];
                        accountProgress[account.account_id] = {
                            ...progress,
                            percent: 100,
                            current: progress.total || progress.totalCount || 0
                        };
                    }
                });
                updateAccountProgressBars();
                
                // Hide progress after a short delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in email streams:', error);
            }
        }

        function updateAccountProgressBars() {
            const accountProgressBars = document.getElementById('accountProgressBars');
            const progressContainer = document.getElementById('progressContainer');
            
            if (!accountProgressBars || !progressContainer) {
                console.error('Progress bar elements not found');
                return;
            }
            
            // Don't hide if we're in the middle of loading
            if (Object.keys(accountProgress).length === 0 && !isLoading) {
                progressContainer.style.display = 'none';
                return;
            }
            
            // Always show if we have progress data or are loading
            if (Object.keys(accountProgress).length > 0 || isLoading) {
                progressContainer.style.display = 'block';
            }
            
            const barsHtml = Object.entries(accountProgress)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([accountId, progress]) => {
                    const accountNum = accountId.replace('account', '');
                    const accountEmail = accounts.find(a => a.account_id === accountId)?.email || `Account ${accountNum}`;
                    const percent = Math.min(progress.percent || 0, 100);
                    const hasError = progress.error;
                    const total = progress.totalCount || progress.total || 0;
                    const hasTotal = total > 0;
                    const isLoading = percent === 0 && !hasError && !hasTotal;
                    
                    let statsText = '';
                    if (hasError) {
                        statsText = `<span style="color: #c5221f;">Error</span>`;
                    } else if (hasTotal) {
                        // Show count against the batch total (min of BATCH_SIZE and totalCount)
                        const batchTotal = progress.total || Math.min(total, BATCH_SIZE);
                        statsText = `${progress.current || 0} / ${batchTotal}`;
                    } else if (isLoading) {
                        statsText = `<span style="color: #5f6368;">Loading...</span>`;
                    } else {
                        statsText = `${progress.current || 0} / ${progress.total || 0}`;
                    }
                    
                    const fillColor = hasError ? '#ea4335' : '#1a73e8';
                    const barClass = isLoading ? 'loading' : '';
                    
                    return `
                        <div class="account-progress">
                            <div class="account-progress-header">
                                <span class="account-progress-name">${escapeHtml(accountEmail)}</span>
                                <span class="account-progress-stats">${statsText}</span>
                            </div>
                            <div class="progress-bar ${barClass}">
                                <div class="progress-fill" style="width: ${isLoading ? '0' : percent}%; background-color: ${fillColor};"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            accountProgressBars.innerHTML = barsHtml;
        }

        async function loadEmailsRegular() {
            const PAGINATION_SIZE = 5; // Load 5 more emails per account
            
            // Parse nextPageToken to get tokens for each account
            const accountTokens = {};
            if (nextPageToken) {
                const tokens = nextPageToken.split(',');
                for (const tokenPair of tokens) {
                    if (tokenPair.includes(':')) {
                        const [accId, token] = tokenPair.split(':', 2);
                        accountTokens[accId] = token;
                    }
                }
            }
            
            // Get authenticated accounts that have more emails
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            const accountsToLoad = authenticatedAccounts.filter(account => 
                accountTokens[account.account_id] || !nextPageToken
            );
            
            if (accountsToLoad.length === 0) {
                hasMoreEmails = false;
                return;
            }
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Initialize/update progress bars for pagination
            accountsToLoad.forEach(account => {
                const existing = accountProgress[account.account_id] || {};
                const currentLoaded = existing.current || existing.total || 0;
                const newTotal = currentLoaded + PAGINATION_SIZE;
                
                accountProgress[account.account_id] = {
                    current: currentLoaded, // Start from current position
                    total: newTotal, // New total includes the 5 more we're loading
                    totalCount: existing.totalCount || 0,
                    percent: 0,
                    paginationStart: currentLoaded // Remember where we started for this pagination
                };
            });
            updateAccountProgressBars();
            
            // Load 5 more emails from each account in parallel
            const streamPromises = accountsToLoad.map(account => {
                return new Promise((resolve, reject) => {
                    const accountToken = accountTokens[account.account_id];
                    if (!accountToken && nextPageToken) {
                        // This account doesn't have more emails
                        resolve({
                            account_id: account.account_id,
                            emails: [],
                            next_token: null
                        });
                        return;
                    }
                    
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${PAGINATION_SIZE}`;
                    if (accountToken) {
                        url += `&page_token=${encodeURIComponent(accountToken)}`;
                    }
                    
                    const eventSource = new EventSource(url);
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress: add to pagination start point
                                const existing = accountProgress[data.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const progressInBatch = data.current || 0;
                                const progressTotal = existing.total || (paginationStart + PAGINATION_SIZE);
                                
                                accountProgress[data.account_id] = {
                                    current: paginationStart + progressInBatch,
                                    total: progressTotal,
                                    totalCount: existing.totalCount || 0,
                                    percent: progressTotal > 0 ? Math.min((paginationStart + progressInBatch) / progressTotal * 100, 100) : 0,
                                    paginationStart: paginationStart // Preserve start point
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                
                                // Mark as complete
                                const existing = accountProgress[account.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const finalCurrent = paginationStart + accountEmails.length;
                                accountProgress[account.account_id] = {
                                    current: finalCurrent,
                                    total: existing.total || finalCurrent,
                                    totalCount: existing.totalCount || 0,
                                    percent: 100
                                };
                                updateAccountProgressBars();
                                
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Hide progress after a delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in pagination streams:', error);
            }
        }

        function getLabelId(labelName) {
            // Sanitize label name for use in HTML IDs
            return labelName.toLowerCase().replace(/[^a-z0-9]/g, '-');
        }

        function hasLabel(labelNames, labelName) {
            return labelNames.some(label => label.toLowerCase() === labelName.toLowerCase());
        }

        function renderLabelBadges(email, prefix = 'badge') {
            const labelNames = email.label_names || [];
            const labelScores = email.label_scores || {};
            const messageId = escapeHtml(email.id);
            const accountId = escapeHtml(email.account_id || '');
            
            return LABEL_TYPES.map(labelType => {
                const hasLabelValue = hasLabel(labelNames, labelType.name);
                const labelId = getLabelId(labelType.name);
                const badgeId = `${prefix}-${labelId}-${messageId}`;
                const labelDisplayName = labelType.name;
                const escapedLabelName = escapeHtml(labelType.name);
                
                // Get score for this label (if available)
                const score = labelScores[labelType.name.toLowerCase()];
                const scoreText = score !== undefined ? ` (${score}%)` : '';
                
                if (prefix === 'modal') {
                    // Modal badges use addLabel/removeLabel functions
                    if (hasLabelValue) {
                        return `<span class="label-badge" id="${badgeId}" style="cursor: pointer; margin-left: 8px; display: inline-flex; align-items: center; gap: 4px;" onclick="addLabel(event, '${escapedLabelName}')" title="Click to add ${escapeHtml(labelDisplayName)} label">${escapeHtml(labelDisplayName)}<span class="delete-icon" onclick="removeLabel(event, '${escapedLabelName}')" title="Remove ${escapeHtml(labelDisplayName)} label">Ã—</span></span>`;
                    } else {
                        return `<span class="label-badge add-button" id="${badgeId}" style="cursor: pointer; margin-left: 8px; display: inline-flex; align-items: center;" onclick="addLabel(event, '${escapedLabelName}')" title="Click to add ${escapeHtml(labelDisplayName)} label">+ ${escapeHtml(labelDisplayName)}${scoreText}</span>`;
                    }
                } else {
                    // List badges use addLabelFromList/removeLabelFromList functions
                    if (hasLabelValue) {
                        return `<span class="label-badge" id="${badgeId}" style="cursor: pointer; display: inline-flex; align-items: center; gap: 4px;" onclick="addLabelFromList(event, '${messageId}', '${accountId}', '${escapedLabelName}')" title="Click to add ${escapeHtml(labelDisplayName)} label">${escapeHtml(labelDisplayName)}<span class="delete-icon" onclick="removeLabelFromList(event, '${messageId}', '${accountId}', '${escapedLabelName}')" title="Remove ${escapeHtml(labelDisplayName)} label">Ã—</span></span>`;
                    } else {
                        return `<span class="label-badge add-button" id="${badgeId}" style="cursor: pointer; display: inline-flex; align-items: center;" onclick="addLabelFromList(event, '${messageId}', '${accountId}', '${escapedLabelName}')" title="Click to add ${escapeHtml(labelDisplayName)} label">+ ${escapeHtml(labelDisplayName)}${scoreText}</span>`;
                    }
                }
            }).join('');
        }

        function createConfetti() {
            const container = document.getElementById('emailList');
            const colors = ['#ffd700', '#4caf50', '#5b9bd5', '#ff6b6b', '#ffed4e', '#ff9800'];
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.animationDelay = Math.random() * 3 + 's';
                confetti.style.animationDuration = (Math.random() * 2 + 2) + 's';
                container.appendChild(confetti);
                
                setTimeout(() => confetti.remove(), 5000);
            }
        }

        function renderEmails() {
            const emailList = document.getElementById('emailList');
            
            if (allEmails.length === 0) {
                const hasAuthenticated = accounts.some(a => a.authenticated);
                if (!hasAuthenticated) {
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                } else {
                    // TRUE INBOX ZERO - CELEBRATE!
                    const totalAccounts = accounts.filter(a => a.authenticated).length;
                    emailList.innerHTML = `
                        <div class="inbox-zero">
                            <div class="inbox-zero-crown">ðŸ‘‘</div>
                            <div class="inbox-zero-title">Inbox Zero</div>
                            <div class="inbox-zero-subtitle">You Are World Emperor</div>
                            <div class="inbox-zero-message">
                                All your emails have been conquered. Your inbox is pristine, your mind is clear, and your productivity knows no bounds. This is what victory looks like.
                            </div>
                            <div class="inbox-zero-stats">
                                <div class="inbox-zero-stat">
                                    <div class="inbox-zero-stat-value">0</div>
                                    <div class="inbox-zero-stat-label">Emails</div>
                                </div>
                                <div class="inbox-zero-stat">
                                    <div class="inbox-zero-stat-value">${totalAccounts}</div>
                                    <div class="inbox-zero-stat-label">Account${totalAccounts !== 1 ? 's' : ''}</div>
                                </div>
                                <div class="inbox-zero-stat">
                                    <div class="inbox-zero-stat-value">âˆž</div>
                                    <div class="inbox-zero-stat-label">Power</div>
                                </div>
                            </div>
                        </div>
                    `;
                    // Create confetti effect
                    setTimeout(() => createConfetti(), 100);
                }
                updateEmailCount(0);
                return;
            }

            // Filter emails based on showOnlyUnlabeled setting
            let emailsToRender = allEmails;
            if (showOnlyUnlabeled) {
                emailsToRender = allEmails.filter(email => {
                    const labelNames = email.label_names || [];
                    // Only check for custom labels (from labels.yaml), not system labels
                    const customLabelNames = LABEL_TYPES.map(lt => lt.name.toLowerCase());
                    const hasCustomLabel = labelNames.some(labelName => 
                        customLabelNames.includes(labelName.toLowerCase())
                    );
                    return !hasCustomLabel; // Show emails that don't have any custom labels
                });
            }
            
            // Filter by selected label and threshold
            if (selectedLabelFilter) {
                emailsToRender = emailsToRender.filter(email => {
                    const labelNames = email.label_names || [];
                    const labelScores = email.label_scores || {};
                    const selectedLabelLower = selectedLabelFilter.toLowerCase();
                    
                    // Check if label is manually set (counts as 100%)
                    const hasManualLabel = labelNames.some(labelName => 
                        labelName.toLowerCase() === selectedLabelLower
                    );
                    
                    if (hasManualLabel) {
                        return true; // Manually set label = 100%, always passes
                    }
                    
                    // Check model score
                    const score = labelScores[selectedLabelLower];
                    if (score !== undefined) {
                        return score >= labelThreshold;
                    }
                    
                    // If no score available and threshold > 0, don't show
                    return labelThreshold === 0;
                });
            }

            // Sort emails based on filter state
            if (selectedLabelFilter) {
                // Sort by score ascending for the selected label
                const selectedLabelLower = selectedLabelFilter.toLowerCase();
                const customLabelNames = LABEL_TYPES.map(lt => lt.name.toLowerCase());
                emailsToRender.sort((a, b) => {
                    const labelNamesA = a.label_names || [];
                    const labelNamesB = b.label_names || [];
                    const labelScoresA = a.label_scores || {};
                    const labelScoresB = b.label_scores || {};
                    
                    // Check if labels are manually set with the filtered label (counts as 100%)
                    const hasManualLabelA = labelNamesA.some(labelName => 
                        labelName.toLowerCase() === selectedLabelLower
                    );
                    const hasManualLabelB = labelNamesB.some(labelName => 
                        labelName.toLowerCase() === selectedLabelLower
                    );
                    
                    // Check if email has a different manual label (should be treated as 0 for filtered label)
                    const hasDifferentManualLabelA = !hasManualLabelA && labelNamesA.some(labelName => 
                        customLabelNames.includes(labelName.toLowerCase())
                    );
                    const hasDifferentManualLabelB = !hasManualLabelB && labelNamesB.some(labelName => 
                        customLabelNames.includes(labelName.toLowerCase())
                    );
                    
                    // Get scores:
                    // - 100 if manually labeled with filtered label
                    // - 0 if manually labeled with a different custom label
                    // - model score otherwise, or -1 if no score
                    const scoreA = hasManualLabelA ? 100 : (hasDifferentManualLabelA ? 0 : (labelScoresA[selectedLabelLower] ?? -1));
                    const scoreB = hasManualLabelB ? 100 : (hasDifferentManualLabelB ? 0 : (labelScoresB[selectedLabelLower] ?? -1));
                    
                    // Sort ascending (lower scores first)
                    return scoreA - scoreB;
                });
            } else {
                // Sort by time (newest first)
                emailsToRender.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
            }

            if (emailsToRender.length === 0) {
                let emptyMessage = 'No emails found';
                if (showOnlyUnlabeled) {
                    emptyMessage = 'No unlabeled emails found';
                } else if (selectedLabelFilter) {
                    emptyMessage = `No emails found with ${selectedLabelFilter} score â‰¥ ${labelThreshold}%`;
                }
                emailList.innerHTML = `<div class="empty-state"><div class="empty-state-icon">ðŸ“­</div><div>${emptyMessage}</div></div>`;
                updateEmailCount(0);
                return;
            }

            const emailsHtml = emailsToRender.map(email => {
                const sender = parseSender(email.from || 'Unknown');
                const to = email.to || '';
                const subject = email.subject || '(No subject)';
                const snippet = email.snippet || '';
                const timeSent = formatDate(email.date || email.internalDate);
                const isSelected = selectedEmails.has(email.id);
                const labelBadges = renderLabelBadges(email, 'badge');

                return `
                    <div class="email-item has-checkbox" 
                         data-message-id="${escapeHtml(email.id)}"
                         onclick="openEmailModal('${escapeHtml(email.id)}', '${escapeHtml(email.account_id || '')}')">
                        <input type="checkbox" class="email-item-checkbox" 
                               data-message-id="${escapeHtml(email.id)}"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleEmailSelection('${escapeHtml(email.id)}', this.checked)"
                               onclick="event.stopPropagation()">
                        <div class="email-field-label email-sender-label">FROM</div>
                        <div class="email-field-value email-sender-value" title="${escapeHtml(sender)}">
                            ${escapeHtml(sender)}
                        </div>
                        <div class="email-field-label email-subject-label">SUBJECT</div>
                        <div class="email-field-value email-subject-value" title="${escapeHtml(subject)}">
                            ${escapeHtml(subject)}
                        </div>
                        <div class="email-field-label email-time-label">TIME</div>
                        <div class="email-field-value email-time-value">${escapeHtml(timeSent)}</div>
                        <div class="email-field-label email-to-label">TO</div>
                        <div class="email-field-value email-to-value" title="${escapeHtml(to)}">
                            ${escapeHtml(to)}
                        </div>
                        <div class="email-snippet">${escapeHtml(snippet)}</div>
                        <div style="grid-column: 1 / -1; grid-row: 5; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--border);">
                            ${labelBadges}
                        </div>
                    </div>
                `;
            }).join('');

            // Add loading indicator if there are more emails
            let loadingMoreHtml = '';
            if (hasMoreEmails && isLoading) {
                loadingMoreHtml = '<div class="loading-more"><span class="loading-more-spinner"></span>Loading more emails...</div>';
            } else if (hasMoreEmails) {
                loadingMoreHtml = '<div class="loading-more" id="loadMoreTrigger"></div>';
            }

            emailList.innerHTML = emailsHtml + loadingMoreHtml;
            updateEmailCount(emailsToRender.length);
            updateSelectAllCheckbox();
            updateArchiveButton();
        }

        function toggleUnlabeledFilter() {
            const checkbox = document.getElementById('filterUnlabeledCheckbox');
            showOnlyUnlabeled = checkbox.checked;
            renderEmails();
        }

        function updateEmailCount(count) {
            const emailCountEl = document.getElementById('emailCount');
            if (totalEmailCount > 0) {
                emailCountEl.textContent = `Showing ${count} of ${totalEmailCount} emails`;
            } else {
                emailCountEl.textContent = count > 0 ? `${count} emails` : 'No emails';
            }
        }

        function handleScroll() {
            const emailList = document.getElementById('emailList');
            const scrollTop = emailList.scrollTop;
            const scrollHeight = emailList.scrollHeight;
            const clientHeight = emailList.clientHeight;

            // Load more when user scrolls to within 200px of the bottom
            if (scrollHeight - scrollTop - clientHeight < 200) {
                if (hasMoreEmails && !isLoading) {
                    loadMoreEmails(false);
                }
            }
        }

        async function archiveEmail(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            try {
                const response = await fetch(`/api/emails/${messageId}/archive?account_id=${accountId}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to archive email');
                }

                // Remove archived email from the list
                allEmails = allEmails.filter(e => e.id !== messageId);
                renderEmails();
            } catch (error) {
                alert('Error archiving email: ' + error.message);
            }
        }

        async function showAddLabel(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            const labelName = prompt('Enter label name:');
            if (!labelName) return;

            try {
                const response = await fetch(`/api/emails/${messageId}/labels?account_id=${accountId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    throw new Error('Failed to add label');
                }

                // Reload emails to get updated labels
                initializeEmails();
            } catch (error) {
                alert('Error adding label: ' + error.message);
            }
        }

        function parseSender(from) {
            const match = from.match(/^(.+?)\s*<(.+)>$/);
            if (match) {
                return match[1].trim() || match[2];
            }
            return from;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            // Try parsing as internalDate (milliseconds timestamp)
            if (/^\d+$/.test(dateStr)) {
                const date = new Date(parseInt(dateStr));
                return formatDateRelative(date);
            }
            
            // Try parsing as date string
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return formatDateRelative(date);
            }
            
            return dateStr;
        }

        function formatDateRelative(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            // Format as date
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            const currentYear = now.getFullYear();
            
            if (year === currentYear) {
                return `${month} ${day}`;
            } else {
                return `${month} ${day}, ${year}`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showError(message) {
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }

        // Email Modal Functions
        let currentModalEmail = null;

        async function openEmailModal(messageId, accountId) {
            const modal = document.getElementById('emailModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMeta = document.getElementById('modalMeta');
            const modalBody = document.getElementById('modalBody');

            // Show modal with loading state
            modal.classList.add('active');
            modalTitle.textContent = 'Loading...';
            modalMeta.innerHTML = '';
            modalBody.innerHTML = '<div class="modal-loading">Loading email...</div>';

            // If accountId is not provided, try to get it from the map
            if (!accountId) {
                accountId = emailAccountMap[messageId];
            }

            if (!accountId) {
                modalBody.innerHTML = '<div class="modal-error">Error: Could not determine account for this email</div>';
                return;
            }

            try {
                const response = await fetch(`/api/emails/${encodeURIComponent(messageId)}?account_id=${encodeURIComponent(accountId)}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load email: ${response.statusText}`);
                }

                const email = await response.json();
                currentModalEmail = email;

                // Update modal title
                modalTitle.textContent = email.subject || '(No subject)';

                // Update modal meta
                const from = parseSender(email.from || 'Unknown');
                const to = email.to || '';
                const cc = email.cc || '';
                const date = formatDate(email.date || email.internalDate);
                const labelBadges = renderLabelBadges(email, 'modal');
                
                let metaHtml = `
                    <div class="modal-meta-row"><span class="modal-meta-label">From:</span> ${escapeHtml(from)}</div>
                    ${to ? `<div class="modal-meta-row"><span class="modal-meta-label">To:</span> ${escapeHtml(to)}</div>` : ''}
                    ${cc ? `<div class="modal-meta-row"><span class="modal-meta-label">Cc:</span> ${escapeHtml(cc)}</div>` : ''}
                    <div class="modal-meta-row"><span class="modal-meta-label">Date:</span> ${escapeHtml(date)}</div>
                    <div class="modal-meta-row">
                        <span class="modal-meta-label">Labels:</span>
                        ${labelBadges}
                    </div>
                `;
                modalMeta.innerHTML = metaHtml;

                // Update modal body with tabs
                const hasHtml = email.body_html && email.body_html.trim();
                const hasText = email.body && email.body.trim();

                let bodyHtml = '';
                
                if (hasHtml || hasText) {
                    bodyHtml = '<div class="modal-body-tabs">';
                    if (hasHtml) {
                        bodyHtml += '<button class="modal-tab active" onclick="switchEmailTab(\'html\')">HTML</button>';
                    }
                    if (hasText) {
                        bodyHtml += `<button class="modal-tab ${!hasHtml ? 'active' : ''}" onclick="switchEmailTab('text')">Plain Text</button>`;
                    }
                    bodyHtml += '</div>';

                    bodyHtml += '<div class="modal-content">';
                    if (hasHtml) {
                        bodyHtml += `<div id="emailContentHtml" class="modal-content-html" style="display: ${hasHtml ? 'block' : 'none'}"></div>`;
                    }
                    if (hasText) {
                        bodyHtml += `<div id="emailContentText" class="modal-content-text" style="display: ${!hasHtml ? 'block' : 'none'}">${escapeHtml(email.body)}</div>`;
                    }
                    bodyHtml += '</div>';
                    
                    modalBody.innerHTML = bodyHtml;
                    
                    // Set HTML content after DOM is updated (for proper rendering)
                    if (hasHtml) {
                        const htmlContentDiv = document.getElementById('emailContentHtml');
                        if (htmlContentDiv) {
                            htmlContentDiv.innerHTML = email.body_html;
                        }
                    }
                } else {
                    bodyHtml = '<div class="modal-content"><p style="color: #5f6368; font-style: italic;">No content available</p></div>';
                    modalBody.innerHTML = bodyHtml;
                }
            } catch (error) {
                console.error('Error loading email:', error);
                modalBody.innerHTML = `<div class="modal-error">Error loading email: ${escapeHtml(error.message)}</div>`;
            }
        }

        async function addLabel(event, labelName) {
            if (event) {
                event.stopPropagation();
            }
            if (!currentModalEmail) {
                return;
            }

            const messageId = currentModalEmail.id;
            const accountId = currentModalEmail.account_id;
            const labelNames = currentModalEmail.label_names || [];
            const hasLabelValue = hasLabel(labelNames, labelName);

            if (hasLabelValue) {
                return; // Already has label
            }

            const labelId = getLabelId(labelName);
            const badge = document.getElementById(`modal-${labelId}-${escapeHtml(messageId)}`);
            if (badge) {
                badge.classList.add('loading');
                badge.style.display = 'inline-flex';
                badge.style.alignItems = 'center';
                badge.style.gap = '4px';
                badge.innerHTML = `+ ${escapeHtml(labelName)}<span class="loading-spinner"></span>`;
            }

            try {
                const url = `/api/emails/${encodeURIComponent(messageId)}/labels?account_id=${encodeURIComponent(accountId)}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Failed to add label: ${response.statusText}`);
                }

                // Update the current email data
                currentModalEmail.label_names = [...labelNames, labelName];

                // Refresh the modal display
                refreshModalBadge();

                // Also update the email in the list if it's visible
                const email = allEmails.find(e => e.id === messageId);
                if (email) {
                    email.label_names = currentModalEmail.label_names;
                    renderEmails();
                }
            } catch (error) {
                console.error(`Error adding ${labelName} label:`, error);
                alert(`Error adding ${labelName} label: ` + error.message);
                // Restore badge on error
                if (badge) {
                    badge.classList.remove('loading');
                    refreshModalBadge();
                }
            }
        }

        async function removeLabel(event, labelName) {
            if (event) {
                event.stopPropagation();
            }
            if (!currentModalEmail) {
                return;
            }

            const messageId = currentModalEmail.id;
            const accountId = currentModalEmail.account_id;
            const labelNames = currentModalEmail.label_names || [];
            const hasLabelValue = hasLabel(labelNames, labelName);

            if (!hasLabelValue) {
                return; // Doesn't have label
            }

            const labelId = getLabelId(labelName);
            const badge = document.getElementById(`modal-${labelId}-${escapeHtml(messageId)}`);
            if (badge) {
                badge.classList.add('loading');
                badge.innerHTML = `${escapeHtml(labelName)}<span class="loading-spinner"></span>`;
            }

            try {
                const url = `/api/emails/${encodeURIComponent(messageId)}/labels?account_id=${encodeURIComponent(accountId)}`;
                
                const response = await fetch(url, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Failed to remove label: ${response.statusText}`);
                }

                // Update the current email data
                currentModalEmail.label_names = labelNames.filter(label => label.toLowerCase() !== labelName.toLowerCase());

                // Refresh the modal display
                refreshModalBadge();

                // Also update the email in the list if it's visible
                const email = allEmails.find(e => e.id === messageId);
                if (email) {
                    email.label_names = currentModalEmail.label_names;
                    renderEmails();
                }
            } catch (error) {
                console.error(`Error removing ${labelName} label:`, error);
                alert(`Error removing ${labelName} label: ` + error.message);
                // Restore badge on error
                if (badge) {
                    badge.classList.remove('loading');
                    refreshModalBadge();
                }
            }
        }

        async function addLabelFromList(event, messageId, accountId, labelName) {
            if (event) {
                event.stopPropagation();
            }

            if (!messageId || !accountId) {
                return;
            }

            const email = allEmails.find(e => e.id === messageId);
            if (!email) {
                return;
            }

            const labelNames = email.label_names || [];
            const hasLabelValue = hasLabel(labelNames, labelName);

            if (hasLabelValue) {
                return; // Already has label
            }

            const labelId = getLabelId(labelName);
            const badge = document.getElementById(`badge-${labelId}-${messageId}`);
            if (badge) {
                badge.classList.add('loading');
                badge.style.display = 'inline-flex';
                badge.style.alignItems = 'center';
                badge.style.gap = '4px';
                badge.innerHTML = `+ ${escapeHtml(labelName)}<span class="loading-spinner"></span>`;
            }

            try {
                const url = `/api/emails/${encodeURIComponent(messageId)}/labels?account_id=${encodeURIComponent(accountId)}`;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Failed to add label: ${response.statusText}`);
                }

                // Update the email data
                email.label_names = [...labelNames, labelName];

                // Refresh the list display
                renderEmails();

                // Also update modal if it's open for this email
                if (currentModalEmail && currentModalEmail.id === messageId) {
                    currentModalEmail.label_names = email.label_names;
                    refreshModalBadge();
                }
            } catch (error) {
                console.error(`Error adding ${labelName} label:`, error);
                alert(`Error adding ${labelName} label: ` + error.message);
                // Restore badge on error
                if (badge) {
                    badge.classList.remove('loading');
                    renderEmails();
                }
            }
        }

        async function removeLabelFromList(event, messageId, accountId, labelName) {
            if (event) {
                event.stopPropagation();
            }

            if (!messageId || !accountId) {
                return;
            }

            const email = allEmails.find(e => e.id === messageId);
            if (!email) {
                return;
            }

            const labelNames = email.label_names || [];
            const hasLabelValue = hasLabel(labelNames, labelName);

            if (!hasLabelValue) {
                return; // Doesn't have label
            }

            const labelId = getLabelId(labelName);
            const badge = document.getElementById(`badge-${labelId}-${messageId}`);
            if (badge) {
                badge.classList.add('loading');
                badge.innerHTML = `${escapeHtml(labelName)}<span class="loading-spinner"></span>`;
            }

            try {
                const url = `/api/emails/${encodeURIComponent(messageId)}/labels?account_id=${encodeURIComponent(accountId)}`;
                
                const response = await fetch(url, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    throw new Error(errorData.detail || `Failed to remove label: ${response.statusText}`);
                }

                // Update the email data
                email.label_names = labelNames.filter(label => label.toLowerCase() !== labelName.toLowerCase());

                // Refresh the list display
                renderEmails();

                // Also update modal if it's open for this email
                if (currentModalEmail && currentModalEmail.id === messageId) {
                    currentModalEmail.label_names = email.label_names;
                    refreshModalBadge();
                }
            } catch (error) {
                console.error(`Error removing ${labelName} label:`, error);
                alert(`Error removing ${labelName} label: ` + error.message);
                // Restore badge on error
                if (badge) {
                    badge.classList.remove('loading');
                    renderEmails();
                }
            }
        }

        function refreshModalBadge() {
            if (!currentModalEmail) {
                return;
            }

            const modalMeta = document.getElementById('modalMeta');
            const from = parseSender(currentModalEmail.from || 'Unknown');
            const to = currentModalEmail.to || '';
            const cc = currentModalEmail.cc || '';
            const date = formatDate(currentModalEmail.date || currentModalEmail.internalDate);
            const labelBadges = renderLabelBadges(currentModalEmail, 'modal');
            
            let metaHtml = `
                <div class="modal-meta-row"><span class="modal-meta-label">From:</span> ${escapeHtml(from)}</div>
                ${to ? `<div class="modal-meta-row"><span class="modal-meta-label">To:</span> ${escapeHtml(to)}</div>` : ''}
                ${cc ? `<div class="modal-meta-row"><span class="modal-meta-label">Cc:</span> ${escapeHtml(cc)}</div>` : ''}
                <div class="modal-meta-row"><span class="modal-meta-label">Date:</span> ${escapeHtml(date)}</div>
                <div class="modal-meta-row">
                    <span class="modal-meta-label">Labels:</span>
                    ${labelBadges}
                </div>
            `;
            modalMeta.innerHTML = metaHtml;
        }

        function closeEmailModal() {
            const modal = document.getElementById('emailModal');
            modal.classList.remove('active');
            currentModalEmail = null;
        }

        function switchEmailTab(tab) {
            const tabs = document.querySelectorAll('.modal-tab');
            const htmlContent = document.getElementById('emailContentHtml');
            const textContent = document.getElementById('emailContentText');

            tabs.forEach(t => t.classList.remove('active'));
            
            if (tab === 'html') {
                const htmlTab = document.querySelector('.modal-tab[onclick*="html"]');
                if (htmlTab) htmlTab.classList.add('active');
                if (htmlContent) htmlContent.style.display = 'block';
                if (textContent) textContent.style.display = 'none';
            } else {
                const textTab = document.querySelector('.modal-tab[onclick*="text"]');
                if (textTab) textTab.classList.add('active');
                if (htmlContent) htmlContent.style.display = 'none';
                if (textContent) textContent.style.display = 'block';
            }
        }

        // Close modal when clicking outside
        document.getElementById('emailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEmailModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('emailModal');
                if (modal.classList.contains('active')) {
                    closeEmailModal();
                }
            }
        });

        // Selection management functions
        function toggleEmailSelection(messageId, isChecked) {
            if (isChecked) {
                selectedEmails.add(messageId);
            } else {
                selectedEmails.delete(messageId);
            }
            updateArchiveButton();
            updateSelectAllCheckbox();
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const isChecked = selectAllCheckbox.checked;
            
            // Get the emails that are currently visible (filtered)
            let emailsToSelect = allEmails;
            if (showOnlyUnlabeled) {
                emailsToSelect = allEmails.filter(email => {
                    const labelNames = email.label_names || [];
                    // Only check for custom labels (from labels.yaml), not system labels
                    const customLabelNames = LABEL_TYPES.map(lt => lt.name.toLowerCase());
                    const hasCustomLabel = labelNames.some(labelName => 
                        customLabelNames.includes(labelName.toLowerCase())
                    );
                    return !hasCustomLabel; // Show emails that don't have any custom labels
                });
            }
            
            // Apply label filter if active
            if (selectedLabelFilter) {
                emailsToSelect = emailsToSelect.filter(email => {
                    const labelNames = email.label_names || [];
                    const labelScores = email.label_scores || {};
                    const selectedLabelLower = selectedLabelFilter.toLowerCase();
                    
                    // Check if label is manually set (counts as 100%)
                    const hasManualLabel = labelNames.some(labelName => 
                        labelName.toLowerCase() === selectedLabelLower
                    );
                    
                    if (hasManualLabel) {
                        return true; // Manually set label = 100%, always passes
                    }
                    
                    // Check model score
                    const score = labelScores[selectedLabelLower];
                    if (score !== undefined) {
                        return score >= labelThreshold;
                    }
                    
                    // If no score available and threshold > 0, don't show
                    return labelThreshold === 0;
                });
            }
            
            if (isChecked) {
                // Select all visible emails
                emailsToSelect.forEach(email => {
                    selectedEmails.add(email.id);
                });
            } else {
                // Deselect all
                selectedEmails.clear();
            }
            
            // Update all checkboxes
            document.querySelectorAll('.email-item-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            
            updateArchiveButton();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            
            // Get the emails that are currently visible (filtered)
            let visibleEmails = allEmails;
            if (showOnlyUnlabeled) {
                visibleEmails = allEmails.filter(email => {
                    const labelNames = email.label_names || [];
                    // Only check for custom labels (from labels.yaml), not system labels
                    const customLabelNames = LABEL_TYPES.map(lt => lt.name.toLowerCase());
                    const hasCustomLabel = labelNames.some(labelName => 
                        customLabelNames.includes(labelName.toLowerCase())
                    );
                    return !hasCustomLabel; // Show emails that don't have any custom labels
                });
            }
            
            // Apply label filter if active
            if (selectedLabelFilter) {
                visibleEmails = visibleEmails.filter(email => {
                    const labelNames = email.label_names || [];
                    const labelScores = email.label_scores || {};
                    const selectedLabelLower = selectedLabelFilter.toLowerCase();
                    
                    // Check if label is manually set (counts as 100%)
                    const hasManualLabel = labelNames.some(labelName => 
                        labelName.toLowerCase() === selectedLabelLower
                    );
                    
                    if (hasManualLabel) {
                        return true; // Manually set label = 100%, always passes
                    }
                    
                    // Check model score
                    const score = labelScores[selectedLabelLower];
                    if (score !== undefined) {
                        return score >= labelThreshold;
                    }
                    
                    // If no score available and threshold > 0, don't show
                    return labelThreshold === 0;
                });
            }
            
            if (visibleEmails.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                return;
            }
            
            const selectedCount = selectedEmails.size;
            const visibleSelectedCount = visibleEmails.filter(email => selectedEmails.has(email.id)).length;
            
            if (visibleSelectedCount === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (visibleSelectedCount === visibleEmails.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }

        function selectLabeledEmails() {
            // Get custom label names from LABEL_TYPES
            const customLabelNames = LABEL_TYPES.map(lt => lt.name.toLowerCase());
            
            // Filter emails that have at least one custom label
            const labeledEmails = allEmails.filter(email => {
                const labelNames = email.label_names || [];
                return labelNames.some(labelName => 
                    customLabelNames.includes(labelName.toLowerCase())
                );
            });
            
            // Select all labeled emails
            labeledEmails.forEach(email => {
                selectedEmails.add(email.id);
            });
            
            // Update all checkboxes
            document.querySelectorAll('.email-item-checkbox').forEach(checkbox => {
                const messageId = checkbox.getAttribute('data-message-id');
                if (selectedEmails.has(messageId)) {
                    checkbox.checked = true;
                }
            });
            
            updateArchiveButton();
            updateSelectAllCheckbox();
        }

        function updateArchiveButton() {
            const archiveBtn = document.getElementById('archiveBtn');
            archiveBtn.disabled = selectedEmails.size === 0;
        }

        async function archiveSelectedEmails() {
            if (selectedEmails.size === 0) {
                return;
            }

            const messageIds = Array.from(selectedEmails);
            const accountIds = {};
            messageIds.forEach(messageId => {
                accountIds[messageId] = emailAccountMap[messageId];
            });

            // Show confirmation dialog
            const result = await Swal.fire({
                title: 'Archive Emails?',
                text: `Are you sure you want to archive ${selectedEmails.size} email${selectedEmails.size > 1 ? 's' : ''}?`,
                icon: 'question',
                showCancelButton: true,
                confirmButtonColor: '#1a73e8',
                cancelButtonColor: '#5f6368',
                confirmButtonText: 'Archive',
                cancelButtonText: 'Cancel'
            });

            if (!result.isConfirmed) {
                return;
            }

            // Show loading state
            Swal.fire({
                title: 'Archiving...',
                text: `Archiving ${selectedEmails.size} email${selectedEmails.size > 1 ? 's' : ''}`,
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });

            try {
                const response = await fetch('/api/emails/bulk-archive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message_ids: messageIds,
                        account_ids: accountIds
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to archive emails');
                }

                const data = await response.json();

                // Remove archived emails from the list
                const archivedIds = new Set(data.results.success);
                allEmails = allEmails.filter(e => !archivedIds.has(e.id));
                selectedEmails.clear();

                // Re-render emails
                renderEmails();
                updateArchiveButton();
                updateSelectAllCheckbox();

                // Show success message
                if (data.failed_count > 0) {
                    Swal.fire({
                        title: 'Partially Complete',
                        text: `Archived ${data.archived_count} email${data.archived_count > 1 ? 's' : ''}, ${data.failed_count} failed`,
                        icon: 'warning'
                    });
                } else {
                    Swal.fire({
                        title: 'Success!',
                        text: `Archived ${data.archived_count} email${data.archived_count > 1 ? 's' : ''}`,
                        icon: 'success',
                        timer: 2000,
                        showConfirmButton: false
                    });
                }
            } catch (error) {
                Swal.fire({
                    title: 'Error',
                    text: 'Failed to archive emails: ' + error.message,
                    icon: 'error'
                });
            }
        }
    </script>
</body>
</html>
