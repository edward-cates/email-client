<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gmail Client</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-size: 22px;
            font-weight: 400;
            color: #5f6368;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 256px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            padding: 8px;
        }

        .auth-section {
            padding: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e0e0e0;
        }

        .auth-section-title {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            margin-bottom: 12px;
        }

        .account-item {
            padding: 8px 12px;
            margin-bottom: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fff;
        }

        .account-item.authenticated {
            border-color: #137333;
            background: #e6f4ea;
        }

        .account-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .account-name {
            font-size: 13px;
            font-weight: 500;
            color: #202124;
        }

        .account-email {
            font-size: 12px;
            color: #5f6368;
            margin-bottom: 8px;
        }

        .account-email.authenticated {
            color: #137333;
        }

        .auth-btn {
            width: 100%;
            padding: 6px 12px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .auth-btn:hover {
            background-color: #1557b0;
        }

        .auth-btn.authenticated {
            background-color: #137333;
            cursor: default;
        }

        .auth-status {
            font-size: 11px;
            color: #5f6368;
            margin-top: 4px;
        }

        .auth-status.authenticated {
            color: #137333;
        }

        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #fff;
        }

        .email-header {
            padding: 12px 16px;
            border-bottom: 1px solid #e0e0e0;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .email-count {
            font-size: 14px;
            color: #5f6368;
        }

        .progress-container {
            padding: 12px 16px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .account-progress {
            margin-bottom: 12px;
        }

        .account-progress:last-child {
            margin-bottom: 0;
        }

        .account-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
            color: #5f6368;
        }

        .account-progress-name {
            font-weight: 500;
            color: #202124;
        }

        .account-progress-stats {
            font-size: 11px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #1a73e8;
            transition: width 0.5s ease-out;
            border-radius: 3px;
        }

        .progress-bar.loading {
            position: relative;
            overflow: hidden;
        }

        .progress-bar.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .email-list {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        .loading-more {
            padding: 16px;
            text-align: center;
            color: #5f6368;
            font-size: 13px;
        }

        .loading-more-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-top-color: #1a73e8;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .email-item {
            padding: 16px;
            border-bottom: 1px solid #e8eaed;
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto auto;
            gap: 8px 16px;
            cursor: pointer;
        }

        .email-item:hover {
            background-color: #f8f9fa;
        }

        .email-header-row {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .email-sender {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-time {
            font-size: 13px;
            color: #5f6368;
            margin-left: auto;
            white-space: nowrap;
        }

        .email-subject {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-to {
            font-size: 13px;
            color: #5f6368;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-snippet {
            grid-column: 1 / -1;
            font-size: 13px;
            color: #5f6368;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #5f6368;
        }

        .empty-state-icon {
            font-size: 120px;
            margin-bottom: 16px;
        }

        .loading {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #5f6368;
        }

        .error {
            padding: 16px;
            background-color: #fce8e6;
            color: #c5221f;
            border-radius: 4px;
            margin: 16px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Gmail - Merged Inbox</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="auth-section">
                <div class="auth-section-title">Accounts</div>
                <div id="accountsList">Loading accounts...</div>
            </div>
        </div>

        <div class="content-area">
            <div class="email-header">
                <div class="email-count" id="emailCount">Loading...</div>
            </div>
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div id="accountProgressBars"></div>
            </div>
            <div class="email-list" id="emailList">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <script>
        let accounts = [];
        let emailAccountMap = {}; // Map message_id to account_id
        let allEmails = []; // Store all loaded emails
        let nextPageToken = null;
        let totalEmailCount = 0;
        let isLoading = false;
        let hasMoreEmails = true;
        const BATCH_SIZE = 20; // Number of emails to load per batch

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('auth_success') === 'true') {
            setTimeout(async () => {
                await loadAccounts();
                initializeEmails();
            }, 500);
        }
        if (urlParams.get('auth_error')) {
            showError('Authentication failed: ' + urlParams.get('auth_error'));
        }

        // Load accounts first, then initialize emails
        (async () => {
            await loadAccounts();
            initializeEmails();
        })();

        // Set up infinite scroll
        const emailList = document.getElementById('emailList');
        emailList.addEventListener('scroll', handleScroll);

        async function loadAccounts() {
            try {
                const response = await fetch('/api/accounts');
                const data = await response.json();
                accounts = data.accounts;
                renderAccounts();
            } catch (error) {
                console.error('Error loading accounts:', error);
                document.getElementById('accountsList').innerHTML = '<div class="error">Error loading accounts</div>';
            }
        }

        function renderAccounts() {
            const accountsList = document.getElementById('accountsList');
            if (accounts.length === 0) {
                accountsList.innerHTML = '<div style="color: #5f6368; font-size: 12px;">No accounts found. Add credentials-1.json through credentials-9.json to src/gmail/credentials/</div>';
                return;
            }

            accountsList.innerHTML = accounts.map(account => {
                const accountNum = account.account_id.replace('account', '');
                if (account.authenticated) {
                    return `
                        <div class="account-item authenticated">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                                <span style="color: #137333; font-size: 12px;">âœ“</span>
                            </div>
                            <div class="account-email authenticated">${escapeHtml(account.email || 'Authenticated')}</div>
                            <div class="auth-status authenticated">Authenticated</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="account-item">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                            </div>
                            <div class="account-email">Not authenticated</div>
                            <button class="auth-btn" onclick="startAuth('${escapeHtml(account.account_id)}')">Sign in</button>
                        </div>
                    `;
                }
            }).join('');
        }

        async function startAuth(accountId) {
            try {
                const response = await fetch(`/api/auth/start?account_id=${accountId}`);
                const data = await response.json();
                window.location.href = data.authorization_url;
            } catch (error) {
                showError('Failed to start authentication: ' + error.message);
            }
        }

        async function initializeEmails() {
            allEmails = [];
            nextPageToken = null;
            hasMoreEmails = true;
            
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = '<div class="loading">Loading emails...</div>';
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                return;
            }
            
            // Step 1: Fetch email counts for each account first
            let accountCounts = {};
            try {
                const countsResponse = await fetch('/api/emails/account-counts');
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    accountCounts = countsData.account_counts || {};
                    
                    // Calculate total count
                    totalEmailCount = Object.values(accountCounts).reduce((sum, count) => sum + count, 0);
                    updateEmailCount(0);
                }
            } catch (error) {
                console.error('Error loading email counts:', error);
            }
            
            // Step 2: Initialize progress bars with actual counts (min of BATCH_SIZE and total)
            accountProgress = {};
            authenticatedAccounts.forEach(account => {
                const totalCount = accountCounts[account.account_id] || 0;
                const batchTotal = Math.min(totalCount, BATCH_SIZE);
                accountProgress[account.account_id] = {
                    current: 0,
                    total: batchTotal, // This is what we'll track progress against
                    totalCount: totalCount, // Store full count for display
                    percent: 0
                };
            });
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            updateAccountProgressBars();
            
            // Step 3: Start streaming emails from all accounts in parallel
            await loadMoreEmails(true);
        }

        async function loadMoreEmails(isInitial = false) {
            if (isLoading || (!hasMoreEmails && !isInitial)) {
                return;
            }

            isLoading = true;
            const emailList = document.getElementById('emailList');
            const progressContainer = document.getElementById('progressContainer');

            // Show progress on initial load
            if (isInitial) {
                accountProgress = {}; // Reset progress tracking
                allEmails = []; // Clear existing emails on initial load
            }

            try {
                // Use streaming endpoint for initial load, regular endpoint for pagination
                if (isInitial) {
                    await loadEmailsStream();
                } else {
                    await loadEmailsRegular();
                }

                // Render emails
                renderEmails();

                // Progress hiding is handled in loadEmailsStream

            } catch (error) {
                console.error('Error loading emails:', error);
                if (isInitial) {
                    emailList.innerHTML = `<div class="error">Error loading emails: ${error.message}</div>`;
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error';
                    errorDiv.textContent = `Error loading more emails: ${error.message}`;
                    emailList.appendChild(errorDiv);
                }
            } finally {
                isLoading = false;
            }
        }

        let accountProgress = {}; // Track progress per account
        let accountStreams = {}; // Track EventSource streams per account

        async function loadEmailsStream() {
            const progressContainer = document.getElementById('progressContainer');
            const accountProgressBars = document.getElementById('accountProgressBars');
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                return;
            }
            
            // Ensure progress container is visible
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Ensure accountProgress is initialized for all accounts
            authenticatedAccounts.forEach(account => {
                if (!accountProgress[account.account_id]) {
                    accountProgress[account.account_id] = {
                        current: 0,
                        total: BATCH_SIZE,
                        totalCount: 0,
                        percent: 0
                    };
                }
            });
            updateAccountProgressBars();
            
            // Start streaming from all accounts in parallel
            const streamPromises = authenticatedAccounts.map(account => {
                return new Promise((resolve, reject) => {
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${BATCH_SIZE}`;
                    
                    // Parse nextPageToken to get token for this account if needed
                    if (nextPageToken) {
                        const tokens = nextPageToken.split(',');
                        for (const tokenPair of tokens) {
                            if (tokenPair.includes(':')) {
                                const [accId, token] = tokenPair.split(':', 2);
                                if (accId === account.account_id) {
                                    url += `&page_token=${encodeURIComponent(token)}`;
                                    break;
                                }
                            }
                        }
                    }
                    
                    const eventSource = new EventSource(url);
                    accountStreams[account.account_id] = eventSource;
                    
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress for this account (preserve totalCount and total if they exist)
                                const existing = accountProgress[data.account_id] || {};
                                // Use the existing total (which is min(BATCH_SIZE, totalCount)) for progress tracking
                                const progressTotal = existing.total || data.total || 0;
                                accountProgress[data.account_id] = {
                                    current: data.current || 0,
                                    total: progressTotal, // Keep the batch total we set initially
                                    totalCount: existing.totalCount || 0, // Preserve full count
                                    percent: progressTotal > 0 ? Math.min((data.current || 0) / progressTotal * 100, 100) : 0
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                // Add email as it arrives
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                // Check for duplicates
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally for better UX
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    // Timeout after 60 seconds
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Mark all accounts as complete in progress
                authenticatedAccounts.forEach(account => {
                    if (accountProgress[account.account_id]) {
                        const progress = accountProgress[account.account_id];
                        accountProgress[account.account_id] = {
                            ...progress,
                            percent: 100,
                            current: progress.total || progress.totalCount || 0
                        };
                    }
                });
                updateAccountProgressBars();
                
                // Hide progress after a short delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in email streams:', error);
            }
        }

        function updateAccountProgressBars() {
            const accountProgressBars = document.getElementById('accountProgressBars');
            const progressContainer = document.getElementById('progressContainer');
            
            if (!accountProgressBars || !progressContainer) {
                console.error('Progress bar elements not found');
                return;
            }
            
            // Don't hide if we're in the middle of loading
            if (Object.keys(accountProgress).length === 0 && !isLoading) {
                progressContainer.style.display = 'none';
                return;
            }
            
            // Always show if we have progress data or are loading
            if (Object.keys(accountProgress).length > 0 || isLoading) {
                progressContainer.style.display = 'block';
            }
            
            const barsHtml = Object.entries(accountProgress)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([accountId, progress]) => {
                    const accountNum = accountId.replace('account', '');
                    const accountEmail = accounts.find(a => a.account_id === accountId)?.email || `Account ${accountNum}`;
                    const percent = Math.min(progress.percent || 0, 100);
                    const hasError = progress.error;
                    const total = progress.totalCount || progress.total || 0;
                    const hasTotal = total > 0;
                    const isLoading = percent === 0 && !hasError && !hasTotal;
                    
                    let statsText = '';
                    if (hasError) {
                        statsText = `<span style="color: #c5221f;">Error</span>`;
                    } else if (hasTotal) {
                        // Show count against the batch total (min of BATCH_SIZE and totalCount)
                        const batchTotal = progress.total || Math.min(total, BATCH_SIZE);
                        statsText = `${progress.current || 0} / ${batchTotal}`;
                    } else if (isLoading) {
                        statsText = `<span style="color: #5f6368;">Loading...</span>`;
                    } else {
                        statsText = `${progress.current || 0} / ${progress.total || 0}`;
                    }
                    
                    const fillColor = hasError ? '#ea4335' : '#1a73e8';
                    const barClass = isLoading ? 'loading' : '';
                    
                    return `
                        <div class="account-progress">
                            <div class="account-progress-header">
                                <span class="account-progress-name">${escapeHtml(accountEmail)}</span>
                                <span class="account-progress-stats">${statsText}</span>
                            </div>
                            <div class="progress-bar ${barClass}">
                                <div class="progress-fill" style="width: ${isLoading ? '0' : percent}%; background-color: ${fillColor};"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            accountProgressBars.innerHTML = barsHtml;
        }

        async function loadEmailsRegular() {
            const PAGINATION_SIZE = 5; // Load 5 more emails per account
            
            // Parse nextPageToken to get tokens for each account
            const accountTokens = {};
            if (nextPageToken) {
                const tokens = nextPageToken.split(',');
                for (const tokenPair of tokens) {
                    if (tokenPair.includes(':')) {
                        const [accId, token] = tokenPair.split(':', 2);
                        accountTokens[accId] = token;
                    }
                }
            }
            
            // Get authenticated accounts that have more emails
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            const accountsToLoad = authenticatedAccounts.filter(account => 
                accountTokens[account.account_id] || !nextPageToken
            );
            
            if (accountsToLoad.length === 0) {
                hasMoreEmails = false;
                return;
            }
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Initialize/update progress bars for pagination
            accountsToLoad.forEach(account => {
                const existing = accountProgress[account.account_id] || {};
                const currentLoaded = existing.current || existing.total || 0;
                const newTotal = currentLoaded + PAGINATION_SIZE;
                
                accountProgress[account.account_id] = {
                    current: currentLoaded, // Start from current position
                    total: newTotal, // New total includes the 5 more we're loading
                    totalCount: existing.totalCount || 0,
                    percent: 0,
                    paginationStart: currentLoaded // Remember where we started for this pagination
                };
            });
            updateAccountProgressBars();
            
            // Load 5 more emails from each account in parallel
            const streamPromises = accountsToLoad.map(account => {
                return new Promise((resolve, reject) => {
                    const accountToken = accountTokens[account.account_id];
                    if (!accountToken && nextPageToken) {
                        // This account doesn't have more emails
                        resolve({
                            account_id: account.account_id,
                            emails: [],
                            next_token: null
                        });
                        return;
                    }
                    
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${PAGINATION_SIZE}`;
                    if (accountToken) {
                        url += `&page_token=${encodeURIComponent(accountToken)}`;
                    }
                    
                    const eventSource = new EventSource(url);
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress: add to pagination start point
                                const existing = accountProgress[data.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const progressInBatch = data.current || 0;
                                const progressTotal = existing.total || (paginationStart + PAGINATION_SIZE);
                                
                                accountProgress[data.account_id] = {
                                    current: paginationStart + progressInBatch,
                                    total: progressTotal,
                                    totalCount: existing.totalCount || 0,
                                    percent: progressTotal > 0 ? Math.min((paginationStart + progressInBatch) / progressTotal * 100, 100) : 0,
                                    paginationStart: paginationStart // Preserve start point
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                
                                // Mark as complete
                                const existing = accountProgress[account.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const finalCurrent = paginationStart + accountEmails.length;
                                accountProgress[account.account_id] = {
                                    current: finalCurrent,
                                    total: existing.total || finalCurrent,
                                    totalCount: existing.totalCount || 0,
                                    percent: 100
                                };
                                updateAccountProgressBars();
                                
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Hide progress after a delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in pagination streams:', error);
            }
        }

        function renderEmails() {
            const emailList = document.getElementById('emailList');
            
            if (allEmails.length === 0) {
                const hasAuthenticated = accounts.some(a => a.authenticated);
                if (!hasAuthenticated) {
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                } else {
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“­</div><div>No emails found</div></div>';
                }
                updateEmailCount(0);
                return;
            }

            const emailsHtml = allEmails.map(email => {
                const sender = parseSender(email.from || 'Unknown');
                const to = email.to || '';
                const subject = email.subject || '(No subject)';
                const snippet = email.snippet || '';
                const timeSent = formatDate(email.date || email.internalDate);

                return `
                    <div class="email-item" data-message-id="${escapeHtml(email.id)}">
                        <div class="email-header-row">
                            <div class="email-sender" title="${escapeHtml(sender)}">${escapeHtml(sender)}</div>
                            <div class="email-time">${escapeHtml(timeSent)}</div>
                        </div>
                        <div class="email-subject" title="${escapeHtml(subject)}">${escapeHtml(subject)}</div>
                        <div class="email-to" title="${escapeHtml(to)}">${escapeHtml(to)}</div>
                        <div class="email-snippet">${escapeHtml(snippet)}</div>
                    </div>
                `;
            }).join('');

            // Add loading indicator if there are more emails
            let loadingMoreHtml = '';
            if (hasMoreEmails && isLoading) {
                loadingMoreHtml = '<div class="loading-more"><span class="loading-more-spinner"></span>Loading more emails...</div>';
            } else if (hasMoreEmails) {
                loadingMoreHtml = '<div class="loading-more" id="loadMoreTrigger"></div>';
            }

            emailList.innerHTML = emailsHtml + loadingMoreHtml;
            updateEmailCount(allEmails.length);
        }

        function updateEmailCount(count) {
            const emailCountEl = document.getElementById('emailCount');
            if (totalEmailCount > 0) {
                emailCountEl.textContent = `Showing ${count} of ${totalEmailCount} emails`;
            } else {
                emailCountEl.textContent = count > 0 ? `${count} emails` : 'No emails';
            }
        }

        function handleScroll() {
            const emailList = document.getElementById('emailList');
            const scrollTop = emailList.scrollTop;
            const scrollHeight = emailList.scrollHeight;
            const clientHeight = emailList.clientHeight;

            // Load more when user scrolls to within 200px of the bottom
            if (scrollHeight - scrollTop - clientHeight < 200) {
                if (hasMoreEmails && !isLoading) {
                    loadMoreEmails(false);
                }
            }
        }

        async function archiveEmail(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            try {
                const response = await fetch(`/api/emails/${messageId}/archive?account_id=${accountId}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to archive email');
                }

                // Remove archived email from the list
                allEmails = allEmails.filter(e => e.id !== messageId);
                renderEmails();
            } catch (error) {
                alert('Error archiving email: ' + error.message);
            }
        }

        async function showAddLabel(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            const labelName = prompt('Enter label name:');
            if (!labelName) return;

            try {
                const response = await fetch(`/api/emails/${messageId}/labels?account_id=${accountId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    throw new Error('Failed to add label');
                }

                // Reload emails to get updated labels
                initializeEmails();
            } catch (error) {
                alert('Error adding label: ' + error.message);
            }
        }

        function parseSender(from) {
            const match = from.match(/^(.+?)\s*<(.+)>$/);
            if (match) {
                return match[1].trim() || match[2];
            }
            return from;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            // Try parsing as internalDate (milliseconds timestamp)
            if (/^\d+$/.test(dateStr)) {
                const date = new Date(parseInt(dateStr));
                return formatDateRelative(date);
            }
            
            // Try parsing as date string
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return formatDateRelative(date);
            }
            
            return dateStr;
        }

        function formatDateRelative(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            // Format as date
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            const currentYear = now.getFullYear();
            
            if (year === currentYear) {
                return `${month} ${day}`;
            } else {
                return `${month} ${day}, ${year}`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showError(message) {
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }
    </script>
</body>
</html>
