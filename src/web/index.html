<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gmail Client</title>
    <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background-color: #fff;
            border-bottom: 1px solid #e0e0e0;
            padding: 12px 16px;
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .logo {
            font-size: 22px;
            font-weight: 400;
            color: #5f6368;
        }

        .main-container {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .sidebar {
            width: 256px;
            background-color: #fff;
            border-right: 1px solid #e0e0e0;
            padding: 8px;
        }

        .auth-section {
            padding: 16px;
            margin-bottom: 16px;
            border-bottom: 1px solid #e0e0e0;
        }

        .auth-section-title {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            margin-bottom: 12px;
        }

        .account-item {
            padding: 8px 12px;
            margin-bottom: 8px;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            background: #fff;
        }

        .account-item.authenticated {
            border-color: #137333;
            background: #e6f4ea;
        }

        .account-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .account-name {
            font-size: 13px;
            font-weight: 500;
            color: #202124;
        }

        .account-email {
            font-size: 12px;
            color: #5f6368;
            margin-bottom: 8px;
        }

        .account-email.authenticated {
            color: #137333;
        }

        .auth-btn {
            width: 100%;
            padding: 6px 12px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
        }

        .auth-btn:hover {
            background-color: #1557b0;
        }

        .auth-btn.authenticated {
            background-color: #137333;
            cursor: default;
        }

        .auth-status {
            font-size: 11px;
            color: #5f6368;
            margin-top: 4px;
        }

        .auth-status.authenticated {
            color: #137333;
        }

        .content-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #fff;
        }

        .email-header {
            padding: 12px 16px;
            border-bottom: 1px solid #e0e0e0;
            background-color: #fff;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 16px;
        }

        .email-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .email-count {
            font-size: 14px;
            color: #5f6368;
        }

        .email-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #1a73e8;
        }

        .archive-btn {
            padding: 8px 16px;
            background-color: #1a73e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
        }

        .archive-btn:hover {
            background-color: #1557b0;
        }

        .archive-btn:disabled {
            background-color: #e0e0e0;
            color: #9aa0a6;
            cursor: not-allowed;
        }

        .progress-container {
            padding: 12px 16px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #e0e0e0;
        }

        .account-progress {
            margin-bottom: 12px;
        }

        .account-progress:last-child {
            margin-bottom: 0;
        }

        .account-progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            font-size: 12px;
            color: #5f6368;
        }

        .account-progress-name {
            font-weight: 500;
            color: #202124;
        }

        .account-progress-stats {
            font-size: 11px;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background-color: #e0e0e0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background-color: #1a73e8;
            transition: width 0.5s ease-out;
            border-radius: 3px;
        }

        .progress-bar.loading {
            position: relative;
            overflow: hidden;
        }

        .progress-bar.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            animation: shimmer 1.5s infinite;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }

        .email-list {
            flex: 1;
            overflow-y: auto;
            position: relative;
        }

        .loading-more {
            padding: 16px;
            text-align: center;
            color: #5f6368;
            font-size: 13px;
        }

        .loading-more-spinner {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #e0e0e0;
            border-top-color: #1a73e8;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            margin-right: 8px;
            vertical-align: middle;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .email-item {
            padding: 16px;
            border-bottom: 1px solid #e8eaed;
            display: grid;
            grid-template-columns: 200px 1fr 180px;
            grid-template-rows: auto auto;
            gap: 8px 16px;
            cursor: pointer;
            position: relative;
        }

        .email-item:hover {
            background-color: #f8f9fa;
        }

        .email-item-checkbox {
            position: absolute;
            left: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #1a73e8;
            z-index: 10;
        }

        .email-item.has-checkbox {
            padding-left: 48px;
        }

        .email-header-row {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .email-sender {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-time {
            font-size: 13px;
            color: #5f6368;
            margin-left: auto;
            white-space: nowrap;
        }

        .email-subject {
            font-size: 14px;
            font-weight: 500;
            color: #202124;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-to {
            font-size: 13px;
            color: #5f6368;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .email-snippet {
            grid-column: 1 / -1;
            font-size: 13px;
            color: #5f6368;
            line-height: 1.4;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }

        .marketing-badge {
            display: inline-block;
            background-color: #1a73e8;
            color: white;
            font-size: 11px;
            font-weight: 500;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
            vertical-align: middle;
        }

        .empty-state {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #5f6368;
        }

        .empty-state-icon {
            font-size: 120px;
            margin-bottom: 16px;
        }

        .loading {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #5f6368;
        }

        .error {
            padding: 16px;
            background-color: #fce8e6;
            color: #c5221f;
            border-radius: 4px;
            margin: 16px;
        }

        /* Modal styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            overflow-y: auto;
            padding: 20px;
        }

        .modal-overlay.active {
            display: flex;
            align-items: flex-start;
            justify-content: center;
        }

        .modal {
            background-color: #fff;
            border-radius: 8px;
            width: 100%;
            max-width: 900px;
            max-height: 90vh;
            margin: 20px auto;
            display: flex;
            flex-direction: column;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .modal-header {
            padding: 20px 24px;
            border-bottom: 1px solid #e0e0e0;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            flex-shrink: 0;
        }

        .modal-header-content {
            flex: 1;
            min-width: 0;
        }

        .modal-title {
            font-size: 20px;
            font-weight: 500;
            color: #202124;
            margin-bottom: 8px;
            word-wrap: break-word;
        }

        .modal-meta {
            font-size: 13px;
            color: #5f6368;
            line-height: 1.5;
        }

        .modal-meta-row {
            margin-bottom: 4px;
        }

        .modal-meta-label {
            font-weight: 500;
            display: inline-block;
            min-width: 60px;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 24px;
            color: #5f6368;
            cursor: pointer;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            flex-shrink: 0;
            margin-left: 16px;
        }

        .modal-close:hover {
            background-color: #f1f3f4;
        }

        .modal-body {
            padding: 24px;
            overflow-y: auto;
            flex: 1;
            min-height: 0;
        }

        .modal-body-tabs {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 16px;
        }

        .modal-tab {
            padding: 8px 16px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 14px;
            color: #5f6368;
            font-weight: 500;
        }

        .modal-tab.active {
            color: #1a73e8;
            border-bottom-color: #1a73e8;
        }

        .modal-tab:hover {
            background-color: #f8f9fa;
        }

        .modal-content {
            font-size: 14px;
            line-height: 1.6;
            color: #202124;
        }

        .modal-content-html {
            max-width: 100%;
            word-wrap: break-word;
        }

        .modal-content-html img {
            max-width: 100%;
            height: auto;
        }

        .modal-content-text {
            white-space: pre-wrap;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        .modal-loading {
            text-align: center;
            padding: 40px;
            color: #5f6368;
        }

        .modal-error {
            padding: 16px;
            background-color: #fce8e6;
            color: #c5221f;
            border-radius: 4px;
            margin: 16px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">Gmail - Merged Inbox</div>
    </div>

    <div class="main-container">
        <div class="sidebar">
            <div class="auth-section">
                <div class="auth-section-title">Accounts</div>
                <div id="accountsList">Loading accounts...</div>
            </div>
        </div>

        <div class="content-area">
            <div class="email-header">
                <div class="email-header-left">
                    <input type="checkbox" class="email-checkbox" id="selectAllCheckbox" onchange="toggleSelectAll()">
                    <div class="email-count" id="emailCount">Loading...</div>
                </div>
                <button class="archive-btn" id="archiveBtn" onclick="archiveSelectedEmails()" disabled>Archive</button>
            </div>
            <div class="progress-container" id="progressContainer" style="display: none;">
                <div id="accountProgressBars"></div>
            </div>
            <div class="email-list" id="emailList">
                <div class="loading">Loading...</div>
            </div>
        </div>
    </div>

    <!-- Email Modal -->
    <div class="modal-overlay" id="emailModal">
        <div class="modal">
            <div class="modal-header">
                <div class="modal-header-content">
                    <div class="modal-title" id="modalTitle">Loading...</div>
                    <div class="modal-meta" id="modalMeta"></div>
                </div>
                <button class="modal-close" onclick="closeEmailModal()" aria-label="Close">Ã—</button>
            </div>
            <div class="modal-body" id="modalBody">
                <div class="modal-loading">Loading email...</div>
            </div>
        </div>
    </div>

    <script>
        let accounts = [];
        let emailAccountMap = {}; // Map message_id to account_id
        let allEmails = []; // Store all loaded emails
        let nextPageToken = null;
        let totalEmailCount = 0;
        let isLoading = false;
        let hasMoreEmails = true;
        const BATCH_SIZE = 20; // Number of emails to load per batch
        let selectedEmails = new Set(); // Set of selected email IDs

        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('auth_success') === 'true') {
            setTimeout(async () => {
                await loadAccounts();
                initializeEmails();
            }, 500);
        }
        if (urlParams.get('auth_error')) {
            showError('Authentication failed: ' + urlParams.get('auth_error'));
        }

        // Load accounts first, then initialize emails
        (async () => {
            await loadAccounts();
            initializeEmails();
        })();

        // Set up infinite scroll
        const emailList = document.getElementById('emailList');
        emailList.addEventListener('scroll', handleScroll);

        async function loadAccounts() {
            try {
                const response = await fetch('/api/accounts');
                const data = await response.json();
                accounts = data.accounts;
                renderAccounts();
            } catch (error) {
                console.error('Error loading accounts:', error);
                document.getElementById('accountsList').innerHTML = '<div class="error">Error loading accounts</div>';
            }
        }

        function renderAccounts() {
            const accountsList = document.getElementById('accountsList');
            if (accounts.length === 0) {
                accountsList.innerHTML = '<div style="color: #5f6368; font-size: 12px;">No accounts found. Add credentials-1.json through credentials-9.json to src/gmail/credentials/</div>';
                return;
            }

            accountsList.innerHTML = accounts.map(account => {
                const accountNum = account.account_id.replace('account', '');
                if (account.authenticated) {
                    return `
                        <div class="account-item authenticated">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                                <span style="color: #137333; font-size: 12px;">âœ“</span>
                            </div>
                            <div class="account-email authenticated">${escapeHtml(account.email || 'Authenticated')}</div>
                            <div class="auth-status authenticated">Authenticated</div>
                        </div>
                    `;
                } else {
                    return `
                        <div class="account-item">
                            <div class="account-header">
                                <div class="account-name">Account ${accountNum}</div>
                            </div>
                            <div class="account-email">Not authenticated</div>
                            <button class="auth-btn" onclick="startAuth('${escapeHtml(account.account_id)}')">Sign in</button>
                        </div>
                    `;
                }
            }).join('');
        }

        async function startAuth(accountId) {
            try {
                const response = await fetch(`/api/auth/start?account_id=${accountId}`);
                const data = await response.json();
                window.location.href = data.authorization_url;
            } catch (error) {
                showError('Failed to start authentication: ' + error.message);
            }
        }

        async function initializeEmails() {
            allEmails = [];
            nextPageToken = null;
            hasMoreEmails = true;
            
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = '<div class="loading">Loading emails...</div>';
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                return;
            }
            
            // Step 1: Fetch email counts for each account first
            let accountCounts = {};
            try {
                const countsResponse = await fetch('/api/emails/account-counts');
                if (countsResponse.ok) {
                    const countsData = await countsResponse.json();
                    accountCounts = countsData.account_counts || {};
                    
                    // Calculate total count
                    totalEmailCount = Object.values(accountCounts).reduce((sum, count) => sum + count, 0);
                    updateEmailCount(0);
                }
            } catch (error) {
                console.error('Error loading email counts:', error);
            }
            
            // Step 2: Initialize progress bars with actual counts (min of BATCH_SIZE and total)
            accountProgress = {};
            authenticatedAccounts.forEach(account => {
                const totalCount = accountCounts[account.account_id] || 0;
                const batchTotal = Math.min(totalCount, BATCH_SIZE);
                accountProgress[account.account_id] = {
                    current: 0,
                    total: batchTotal, // This is what we'll track progress against
                    totalCount: totalCount, // Store full count for display
                    percent: 0
                };
            });
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            updateAccountProgressBars();
            
            // Step 3: Start streaming emails from all accounts in parallel
            await loadMoreEmails(true);
        }

        async function loadMoreEmails(isInitial = false) {
            if (isLoading || (!hasMoreEmails && !isInitial)) {
                return;
            }

            isLoading = true;
            const emailList = document.getElementById('emailList');
            const progressContainer = document.getElementById('progressContainer');

            // Show progress on initial load
            if (isInitial) {
                accountProgress = {}; // Reset progress tracking
                allEmails = []; // Clear existing emails on initial load
            }

            try {
                // Use streaming endpoint for initial load, regular endpoint for pagination
                if (isInitial) {
                    await loadEmailsStream();
                } else {
                    await loadEmailsRegular();
                }

                // Render emails
                renderEmails();

                // Progress hiding is handled in loadEmailsStream

            } catch (error) {
                console.error('Error loading emails:', error);
                if (isInitial) {
                    emailList.innerHTML = `<div class="error">Error loading emails: ${error.message}</div>`;
                } else {
                    const errorDiv = document.createElement('div');
                    errorDiv.className = 'error';
                    errorDiv.textContent = `Error loading more emails: ${error.message}`;
                    emailList.appendChild(errorDiv);
                }
            } finally {
                isLoading = false;
            }
        }

        let accountProgress = {}; // Track progress per account
        let accountStreams = {}; // Track EventSource streams per account

        async function loadEmailsStream() {
            const progressContainer = document.getElementById('progressContainer');
            const accountProgressBars = document.getElementById('accountProgressBars');
            
            // Get authenticated accounts
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            
            if (authenticatedAccounts.length === 0) {
                return;
            }
            
            // Ensure progress container is visible
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Ensure accountProgress is initialized for all accounts
            authenticatedAccounts.forEach(account => {
                if (!accountProgress[account.account_id]) {
                    accountProgress[account.account_id] = {
                        current: 0,
                        total: BATCH_SIZE,
                        totalCount: 0,
                        percent: 0
                    };
                }
            });
            updateAccountProgressBars();
            
            // Start streaming from all accounts in parallel
            const streamPromises = authenticatedAccounts.map(account => {
                return new Promise((resolve, reject) => {
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${BATCH_SIZE}`;
                    
                    // Parse nextPageToken to get token for this account if needed
                    if (nextPageToken) {
                        const tokens = nextPageToken.split(',');
                        for (const tokenPair of tokens) {
                            if (tokenPair.includes(':')) {
                                const [accId, token] = tokenPair.split(':', 2);
                                if (accId === account.account_id) {
                                    url += `&page_token=${encodeURIComponent(token)}`;
                                    break;
                                }
                            }
                        }
                    }
                    
                    const eventSource = new EventSource(url);
                    accountStreams[account.account_id] = eventSource;
                    
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress for this account (preserve totalCount and total if they exist)
                                const existing = accountProgress[data.account_id] || {};
                                // Use the existing total (which is min(BATCH_SIZE, totalCount)) for progress tracking
                                const progressTotal = existing.total || data.total || 0;
                                accountProgress[data.account_id] = {
                                    current: data.current || 0,
                                    total: progressTotal, // Keep the batch total we set initially
                                    totalCount: existing.totalCount || 0, // Preserve full count
                                    percent: progressTotal > 0 ? Math.min((data.current || 0) / progressTotal * 100, 100) : 0
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                // Add email as it arrives
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                // Check for duplicates
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally for better UX
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    // Timeout after 60 seconds
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Mark all accounts as complete in progress
                authenticatedAccounts.forEach(account => {
                    if (accountProgress[account.account_id]) {
                        const progress = accountProgress[account.account_id];
                        accountProgress[account.account_id] = {
                            ...progress,
                            percent: 100,
                            current: progress.total || progress.totalCount || 0
                        };
                    }
                });
                updateAccountProgressBars();
                
                // Hide progress after a short delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in email streams:', error);
            }
        }

        function updateAccountProgressBars() {
            const accountProgressBars = document.getElementById('accountProgressBars');
            const progressContainer = document.getElementById('progressContainer');
            
            if (!accountProgressBars || !progressContainer) {
                console.error('Progress bar elements not found');
                return;
            }
            
            // Don't hide if we're in the middle of loading
            if (Object.keys(accountProgress).length === 0 && !isLoading) {
                progressContainer.style.display = 'none';
                return;
            }
            
            // Always show if we have progress data or are loading
            if (Object.keys(accountProgress).length > 0 || isLoading) {
                progressContainer.style.display = 'block';
            }
            
            const barsHtml = Object.entries(accountProgress)
                .sort(([a], [b]) => a.localeCompare(b))
                .map(([accountId, progress]) => {
                    const accountNum = accountId.replace('account', '');
                    const accountEmail = accounts.find(a => a.account_id === accountId)?.email || `Account ${accountNum}`;
                    const percent = Math.min(progress.percent || 0, 100);
                    const hasError = progress.error;
                    const total = progress.totalCount || progress.total || 0;
                    const hasTotal = total > 0;
                    const isLoading = percent === 0 && !hasError && !hasTotal;
                    
                    let statsText = '';
                    if (hasError) {
                        statsText = `<span style="color: #c5221f;">Error</span>`;
                    } else if (hasTotal) {
                        // Show count against the batch total (min of BATCH_SIZE and totalCount)
                        const batchTotal = progress.total || Math.min(total, BATCH_SIZE);
                        statsText = `${progress.current || 0} / ${batchTotal}`;
                    } else if (isLoading) {
                        statsText = `<span style="color: #5f6368;">Loading...</span>`;
                    } else {
                        statsText = `${progress.current || 0} / ${progress.total || 0}`;
                    }
                    
                    const fillColor = hasError ? '#ea4335' : '#1a73e8';
                    const barClass = isLoading ? 'loading' : '';
                    
                    return `
                        <div class="account-progress">
                            <div class="account-progress-header">
                                <span class="account-progress-name">${escapeHtml(accountEmail)}</span>
                                <span class="account-progress-stats">${statsText}</span>
                            </div>
                            <div class="progress-bar ${barClass}">
                                <div class="progress-fill" style="width: ${isLoading ? '0' : percent}%; background-color: ${fillColor};"></div>
                            </div>
                        </div>
                    `;
                }).join('');
            
            accountProgressBars.innerHTML = barsHtml;
        }

        async function loadEmailsRegular() {
            const PAGINATION_SIZE = 5; // Load 5 more emails per account
            
            // Parse nextPageToken to get tokens for each account
            const accountTokens = {};
            if (nextPageToken) {
                const tokens = nextPageToken.split(',');
                for (const tokenPair of tokens) {
                    if (tokenPair.includes(':')) {
                        const [accId, token] = tokenPair.split(':', 2);
                        accountTokens[accId] = token;
                    }
                }
            }
            
            // Get authenticated accounts that have more emails
            const authenticatedAccounts = accounts.filter(a => a.authenticated);
            const accountsToLoad = authenticatedAccounts.filter(account => 
                accountTokens[account.account_id] || !nextPageToken
            );
            
            if (accountsToLoad.length === 0) {
                hasMoreEmails = false;
                return;
            }
            
            // Show progress container
            const progressContainer = document.getElementById('progressContainer');
            if (progressContainer) {
                progressContainer.style.display = 'block';
            }
            
            // Initialize/update progress bars for pagination
            accountsToLoad.forEach(account => {
                const existing = accountProgress[account.account_id] || {};
                const currentLoaded = existing.current || existing.total || 0;
                const newTotal = currentLoaded + PAGINATION_SIZE;
                
                accountProgress[account.account_id] = {
                    current: currentLoaded, // Start from current position
                    total: newTotal, // New total includes the 5 more we're loading
                    totalCount: existing.totalCount || 0,
                    percent: 0,
                    paginationStart: currentLoaded // Remember where we started for this pagination
                };
            });
            updateAccountProgressBars();
            
            // Load 5 more emails from each account in parallel
            const streamPromises = accountsToLoad.map(account => {
                return new Promise((resolve, reject) => {
                    const accountToken = accountTokens[account.account_id];
                    if (!accountToken && nextPageToken) {
                        // This account doesn't have more emails
                        resolve({
                            account_id: account.account_id,
                            emails: [],
                            next_token: null
                        });
                        return;
                    }
                    
                    let url = `/api/emails/stream?account_id=${encodeURIComponent(account.account_id)}&max_results=${PAGINATION_SIZE}`;
                    if (accountToken) {
                        url += `&page_token=${encodeURIComponent(accountToken)}`;
                    }
                    
                    const eventSource = new EventSource(url);
                    const accountEmails = [];
                    let accountNextToken = null;
                    let streamComplete = false;
                    
                    eventSource.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            
                            if (data.type === 'progress') {
                                // Update progress: add to pagination start point
                                const existing = accountProgress[data.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const progressInBatch = data.current || 0;
                                const progressTotal = existing.total || (paginationStart + PAGINATION_SIZE);
                                
                                accountProgress[data.account_id] = {
                                    current: paginationStart + progressInBatch,
                                    total: progressTotal,
                                    totalCount: existing.totalCount || 0,
                                    percent: progressTotal > 0 ? Math.min((paginationStart + progressInBatch) / progressTotal * 100, 100) : 0,
                                    paginationStart: paginationStart // Preserve start point
                                };
                                updateAccountProgressBars();
                            } else if (data.type === 'email') {
                                const email = data.email;
                                emailAccountMap[email.id] = email.account_id;
                                
                                if (!allEmails.find(e => e.id === email.id)) {
                                    allEmails.push(email);
                                    accountEmails.push(email);
                                }
                                
                                // Render incrementally
                                if (allEmails.length % 5 === 0) {
                                    renderEmails();
                                }
                            } else if (data.type === 'complete') {
                                streamComplete = true;
                                accountNextToken = data.next_page_token;
                                eventSource.close();
                                
                                // Mark as complete
                                const existing = accountProgress[account.account_id] || {};
                                const paginationStart = existing.paginationStart !== undefined ? existing.paginationStart : (existing.current || 0);
                                const finalCurrent = paginationStart + accountEmails.length;
                                accountProgress[account.account_id] = {
                                    current: finalCurrent,
                                    total: existing.total || finalCurrent,
                                    totalCount: existing.totalCount || 0,
                                    percent: 100
                                };
                                updateAccountProgressBars();
                                
                                resolve({
                                    account_id: account.account_id,
                                    emails: accountEmails,
                                    next_token: accountNextToken
                                });
                            } else if (data.type === 'error') {
                                streamComplete = true;
                                eventSource.close();
                                accountProgress[account.account_id] = {
                                    ...accountProgress[account.account_id],
                                    error: data.message
                                };
                                updateAccountProgressBars();
                                reject(new Error(data.message || 'Unknown error'));
                            }
                        } catch (error) {
                            console.error('Error parsing stream data:', error);
                        }
                    };
                    
                    eventSource.onerror = (error) => {
                        eventSource.close();
                        if (!streamComplete) {
                            accountProgress[account.account_id] = {
                                ...accountProgress[account.account_id],
                                error: 'Connection error'
                            };
                            updateAccountProgressBars();
                            reject(new Error('Stream connection error'));
                        }
                    };
                    
                    setTimeout(() => {
                        if (!streamComplete) {
                            eventSource.close();
                            reject(new Error('Stream timeout'));
                        }
                    }, 60000);
                });
            });
            
            // Wait for all streams to complete
            try {
                const results = await Promise.allSettled(streamPromises);
                
                // Build next_page_token from successful streams
                const accountNextTokens = {};
                for (const result of results) {
                    if (result.status === 'fulfilled' && result.value.next_token) {
                        accountNextTokens[result.value.account_id] = result.value.next_token;
                    }
                }
                
                if (Object.keys(accountNextTokens).length > 0) {
                    nextPageToken = Object.entries(accountNextTokens)
                        .map(([accId, token]) => `${accId}:${token}`)
                        .join(',');
                    hasMoreEmails = true;
                } else {
                    nextPageToken = null;
                    hasMoreEmails = false;
                }
                
                // Sort emails by date (newest first)
                allEmails.sort((a, b) => {
                    const dateA = parseInt(a.internalDate || 0);
                    const dateB = parseInt(b.internalDate || 0);
                    return dateB - dateA;
                });
                
                // Render final emails
                renderEmails();
                
                // Hide progress after a delay
                setTimeout(() => {
                    const progressContainer = document.getElementById('progressContainer');
                    if (progressContainer) {
                        progressContainer.style.display = 'none';
                    }
                }, 2000);
            } catch (error) {
                console.error('Error in pagination streams:', error);
            }
        }

        function renderEmails() {
            const emailList = document.getElementById('emailList');
            
            if (allEmails.length === 0) {
                const hasAuthenticated = accounts.some(a => a.authenticated);
                if (!hasAuthenticated) {
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ”’</div><div>Please sign in to at least one account to view emails</div></div>';
                } else {
                    emailList.innerHTML = '<div class="empty-state"><div class="empty-state-icon">ðŸ“­</div><div>No emails found</div></div>';
                }
                updateEmailCount(0);
                return;
            }

            const emailsHtml = allEmails.map(email => {
                const sender = parseSender(email.from || 'Unknown');
                const to = email.to || '';
                const subject = email.subject || '(No subject)';
                const snippet = email.snippet || '';
                const timeSent = formatDate(email.date || email.internalDate);
                const isSelected = selectedEmails.has(email.id);
                const labelNames = email.label_names || [];
                const hasMarketingLabel = labelNames.some(label => label.toLowerCase() === 'marketing');

                return `
                    <div class="email-item has-checkbox" 
                         data-message-id="${escapeHtml(email.id)}"
                         onclick="openEmailModal('${escapeHtml(email.id)}', '${escapeHtml(email.account_id || '')}')">
                        <input type="checkbox" class="email-item-checkbox" 
                               data-message-id="${escapeHtml(email.id)}"
                               ${isSelected ? 'checked' : ''}
                               onchange="toggleEmailSelection('${escapeHtml(email.id)}', this.checked)"
                               onclick="event.stopPropagation()">
                        <div class="email-header-row">
                            <div class="email-sender" title="${escapeHtml(sender)}">
                                ${escapeHtml(sender)}
                                ${hasMarketingLabel ? '<span class="marketing-badge">Marketing</span>' : ''}
                            </div>
                            <div class="email-time">${escapeHtml(timeSent)}</div>
                        </div>
                        <div class="email-subject" title="${escapeHtml(subject)}">${escapeHtml(subject)}</div>
                        <div class="email-to" title="${escapeHtml(to)}">${escapeHtml(to)}</div>
                        <div class="email-snippet">${escapeHtml(snippet)}</div>
                    </div>
                `;
            }).join('');

            // Add loading indicator if there are more emails
            let loadingMoreHtml = '';
            if (hasMoreEmails && isLoading) {
                loadingMoreHtml = '<div class="loading-more"><span class="loading-more-spinner"></span>Loading more emails...</div>';
            } else if (hasMoreEmails) {
                loadingMoreHtml = '<div class="loading-more" id="loadMoreTrigger"></div>';
            }

            emailList.innerHTML = emailsHtml + loadingMoreHtml;
            updateEmailCount(allEmails.length);
            updateSelectAllCheckbox();
            updateArchiveButton();
        }

        function updateEmailCount(count) {
            const emailCountEl = document.getElementById('emailCount');
            if (totalEmailCount > 0) {
                emailCountEl.textContent = `Showing ${count} of ${totalEmailCount} emails`;
            } else {
                emailCountEl.textContent = count > 0 ? `${count} emails` : 'No emails';
            }
        }

        function handleScroll() {
            const emailList = document.getElementById('emailList');
            const scrollTop = emailList.scrollTop;
            const scrollHeight = emailList.scrollHeight;
            const clientHeight = emailList.clientHeight;

            // Load more when user scrolls to within 200px of the bottom
            if (scrollHeight - scrollTop - clientHeight < 200) {
                if (hasMoreEmails && !isLoading) {
                    loadMoreEmails(false);
                }
            }
        }

        async function archiveEmail(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            try {
                const response = await fetch(`/api/emails/${messageId}/archive?account_id=${accountId}`, {
                    method: 'POST'
                });

                if (!response.ok) {
                    throw new Error('Failed to archive email');
                }

                // Remove archived email from the list
                allEmails = allEmails.filter(e => e.id !== messageId);
                renderEmails();
            } catch (error) {
                alert('Error archiving email: ' + error.message);
            }
        }

        async function showAddLabel(messageId) {
            const accountId = emailAccountMap[messageId];
            if (!accountId) {
                alert('Error: Could not determine account for this email');
                return;
            }

            const labelName = prompt('Enter label name:');
            if (!labelName) return;

            try {
                const response = await fetch(`/api/emails/${messageId}/labels?account_id=${accountId}`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ label_names: [labelName] })
                });

                if (!response.ok) {
                    throw new Error('Failed to add label');
                }

                // Reload emails to get updated labels
                initializeEmails();
            } catch (error) {
                alert('Error adding label: ' + error.message);
            }
        }

        function parseSender(from) {
            const match = from.match(/^(.+?)\s*<(.+)>$/);
            if (match) {
                return match[1].trim() || match[2];
            }
            return from;
        }

        function formatDate(dateStr) {
            if (!dateStr) return '';
            
            // Try parsing as internalDate (milliseconds timestamp)
            if (/^\d+$/.test(dateStr)) {
                const date = new Date(parseInt(dateStr));
                return formatDateRelative(date);
            }
            
            // Try parsing as date string
            const date = new Date(dateStr);
            if (!isNaN(date.getTime())) {
                return formatDateRelative(date);
            }
            
            return dateStr;
        }

        function formatDateRelative(date) {
            const now = new Date();
            const diffMs = now - date;
            const diffMins = Math.floor(diffMs / 60000);
            const diffHours = Math.floor(diffMs / 3600000);
            const diffDays = Math.floor(diffMs / 86400000);
            
            if (diffMins < 1) return 'Just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            
            // Format as date
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const month = months[date.getMonth()];
            const day = date.getDate();
            const year = date.getFullYear();
            const currentYear = now.getFullYear();
            
            if (year === currentYear) {
                return `${month} ${day}`;
            } else {
                return `${month} ${day}, ${year}`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function showError(message) {
            const emailList = document.getElementById('emailList');
            emailList.innerHTML = `<div class="error">${escapeHtml(message)}</div>`;
        }

        // Email Modal Functions
        async function openEmailModal(messageId, accountId) {
            const modal = document.getElementById('emailModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalMeta = document.getElementById('modalMeta');
            const modalBody = document.getElementById('modalBody');

            // Show modal with loading state
            modal.classList.add('active');
            modalTitle.textContent = 'Loading...';
            modalMeta.innerHTML = '';
            modalBody.innerHTML = '<div class="modal-loading">Loading email...</div>';

            // If accountId is not provided, try to get it from the map
            if (!accountId) {
                accountId = emailAccountMap[messageId];
            }

            if (!accountId) {
                modalBody.innerHTML = '<div class="modal-error">Error: Could not determine account for this email</div>';
                return;
            }

            try {
                const response = await fetch(`/api/emails/${encodeURIComponent(messageId)}?account_id=${encodeURIComponent(accountId)}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load email: ${response.statusText}`);
                }

                const email = await response.json();

                // Update modal title
                modalTitle.textContent = email.subject || '(No subject)';

                // Update modal meta
                const from = parseSender(email.from || 'Unknown');
                const to = email.to || '';
                const cc = email.cc || '';
                const date = formatDate(email.date || email.internalDate);
                
                let metaHtml = `
                    <div class="modal-meta-row"><span class="modal-meta-label">From:</span> ${escapeHtml(from)}</div>
                    ${to ? `<div class="modal-meta-row"><span class="modal-meta-label">To:</span> ${escapeHtml(to)}</div>` : ''}
                    ${cc ? `<div class="modal-meta-row"><span class="modal-meta-label">Cc:</span> ${escapeHtml(cc)}</div>` : ''}
                    <div class="modal-meta-row"><span class="modal-meta-label">Date:</span> ${escapeHtml(date)}</div>
                `;
                modalMeta.innerHTML = metaHtml;

                // Update modal body with tabs
                const hasHtml = email.body_html && email.body_html.trim();
                const hasText = email.body && email.body.trim();

                let bodyHtml = '';
                
                if (hasHtml || hasText) {
                    bodyHtml = '<div class="modal-body-tabs">';
                    if (hasHtml) {
                        bodyHtml += '<button class="modal-tab active" onclick="switchEmailTab(\'html\')">HTML</button>';
                    }
                    if (hasText) {
                        bodyHtml += `<button class="modal-tab ${!hasHtml ? 'active' : ''}" onclick="switchEmailTab('text')">Plain Text</button>`;
                    }
                    bodyHtml += '</div>';

                    bodyHtml += '<div class="modal-content">';
                    if (hasHtml) {
                        bodyHtml += `<div id="emailContentHtml" class="modal-content-html" style="display: ${hasHtml ? 'block' : 'none'}"></div>`;
                    }
                    if (hasText) {
                        bodyHtml += `<div id="emailContentText" class="modal-content-text" style="display: ${!hasHtml ? 'block' : 'none'}">${escapeHtml(email.body)}</div>`;
                    }
                    bodyHtml += '</div>';
                    
                    modalBody.innerHTML = bodyHtml;
                    
                    // Set HTML content after DOM is updated (for proper rendering)
                    if (hasHtml) {
                        const htmlContentDiv = document.getElementById('emailContentHtml');
                        if (htmlContentDiv) {
                            htmlContentDiv.innerHTML = email.body_html;
                        }
                    }
                } else {
                    bodyHtml = '<div class="modal-content"><p style="color: #5f6368; font-style: italic;">No content available</p></div>';
                    modalBody.innerHTML = bodyHtml;
                }
            } catch (error) {
                console.error('Error loading email:', error);
                modalBody.innerHTML = `<div class="modal-error">Error loading email: ${escapeHtml(error.message)}</div>`;
            }
        }

        function closeEmailModal() {
            const modal = document.getElementById('emailModal');
            modal.classList.remove('active');
        }

        function switchEmailTab(tab) {
            const tabs = document.querySelectorAll('.modal-tab');
            const htmlContent = document.getElementById('emailContentHtml');
            const textContent = document.getElementById('emailContentText');

            tabs.forEach(t => t.classList.remove('active'));
            
            if (tab === 'html') {
                const htmlTab = document.querySelector('.modal-tab[onclick*="html"]');
                if (htmlTab) htmlTab.classList.add('active');
                if (htmlContent) htmlContent.style.display = 'block';
                if (textContent) textContent.style.display = 'none';
            } else {
                const textTab = document.querySelector('.modal-tab[onclick*="text"]');
                if (textTab) textTab.classList.add('active');
                if (htmlContent) htmlContent.style.display = 'none';
                if (textContent) textContent.style.display = 'block';
            }
        }

        // Close modal when clicking outside
        document.getElementById('emailModal').addEventListener('click', function(e) {
            if (e.target === this) {
                closeEmailModal();
            }
        });

        // Close modal with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const modal = document.getElementById('emailModal');
                if (modal.classList.contains('active')) {
                    closeEmailModal();
                }
            }
        });

        // Selection management functions
        function toggleEmailSelection(messageId, isChecked) {
            if (isChecked) {
                selectedEmails.add(messageId);
            } else {
                selectedEmails.delete(messageId);
            }
            updateArchiveButton();
            updateSelectAllCheckbox();
        }

        function toggleSelectAll() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            const isChecked = selectAllCheckbox.checked;
            
            if (isChecked) {
                // Select all visible emails
                allEmails.forEach(email => {
                    selectedEmails.add(email.id);
                });
            } else {
                // Deselect all
                selectedEmails.clear();
            }
            
            // Update all checkboxes
            document.querySelectorAll('.email-item-checkbox').forEach(checkbox => {
                checkbox.checked = isChecked;
            });
            
            updateArchiveButton();
        }

        function updateSelectAllCheckbox() {
            const selectAllCheckbox = document.getElementById('selectAllCheckbox');
            if (allEmails.length === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
                return;
            }
            
            const selectedCount = selectedEmails.size;
            if (selectedCount === 0) {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = false;
            } else if (selectedCount === allEmails.length) {
                selectAllCheckbox.checked = true;
                selectAllCheckbox.indeterminate = false;
            } else {
                selectAllCheckbox.checked = false;
                selectAllCheckbox.indeterminate = true;
            }
        }

        function updateArchiveButton() {
            const archiveBtn = document.getElementById('archiveBtn');
            archiveBtn.disabled = selectedEmails.size === 0;
        }

        async function archiveSelectedEmails() {
            if (selectedEmails.size === 0) {
                return;
            }

            const messageIds = Array.from(selectedEmails);
            const accountIds = {};
            messageIds.forEach(messageId => {
                accountIds[messageId] = emailAccountMap[messageId];
            });

            // Show confirmation dialog
            const result = await Swal.fire({
                title: 'Archive Emails?',
                text: `Are you sure you want to archive ${selectedEmails.size} email${selectedEmails.size > 1 ? 's' : ''}?`,
                icon: 'question',
                showCancelButton: true,
                confirmButtonColor: '#1a73e8',
                cancelButtonColor: '#5f6368',
                confirmButtonText: 'Archive',
                cancelButtonText: 'Cancel'
            });

            if (!result.isConfirmed) {
                return;
            }

            // Show loading state
            Swal.fire({
                title: 'Archiving...',
                text: `Archiving ${selectedEmails.size} email${selectedEmails.size > 1 ? 's' : ''}`,
                allowOutsideClick: false,
                didOpen: () => {
                    Swal.showLoading();
                }
            });

            try {
                const response = await fetch('/api/emails/bulk-archive', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        message_ids: messageIds,
                        account_ids: accountIds
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to archive emails');
                }

                const data = await response.json();

                // Remove archived emails from the list
                const archivedIds = new Set(data.results.success);
                allEmails = allEmails.filter(e => !archivedIds.has(e.id));
                selectedEmails.clear();

                // Re-render emails
                renderEmails();
                updateArchiveButton();
                updateSelectAllCheckbox();

                // Show success message
                if (data.failed_count > 0) {
                    Swal.fire({
                        title: 'Partially Complete',
                        text: `Archived ${data.archived_count} email${data.archived_count > 1 ? 's' : ''}, ${data.failed_count} failed`,
                        icon: 'warning'
                    });
                } else {
                    Swal.fire({
                        title: 'Success!',
                        text: `Archived ${data.archived_count} email${data.archived_count > 1 ? 's' : ''}`,
                        icon: 'success',
                        timer: 2000,
                        showConfirmButton: false
                    });
                }
            } catch (error) {
                Swal.fire({
                    title: 'Error',
                    text: 'Failed to archive emails: ' + error.message,
                    icon: 'error'
                });
            }
        }
    </script>
</body>
</html>
